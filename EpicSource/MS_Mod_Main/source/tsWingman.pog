//*******************************************************************************************/
//
// tsWingman.pog
//
// This file implements a wingman control task. It takes orders from the player and gives
// feedback to the player when orders are complete, or have gone wrong.
// 
// Each wingman becomes a state driven AI entity. This forms a new layer between the PS AI
// interface and the player orders.
//
// November 2006, Jon Freise
//******************************************************************************************/

package tsWingman;

uses    Sim,
iShip,
iSim,
iPilotSetup,
Debug,
Global,
GUI,
iDirector,
iGUI,
iHUD,
iHabitat,
iMapEntity,
INIFile,
Input,
List,
Object,
String,
Task,
Text,
iUtilities,
iCargo,
iInventory,
iComms,
iConversation,
iAi,
Math,
CargoTypes,

   tsShipEnum,
tsShip,
tFormation,
tPodUtil,
tsFaction,
tStationEnum,
tStation,
tLProduction,
tMegaTrucking;



provides GiveOrder,
         Start,
         OrderTarget,
         CurrentOrder,
         Save,
         Restore;

   





// These are a series of states that implement orders.
enum eShipState {
   eSS_None,
   eSS_NoPlayer,
   eSS_Idle,

   eSS_HaltStart,
   eSS_HaltWait,

   // Defensive escort of the the target (warships).
   eSS_EscortStart,   
   eSS_Escort,

   // Move into formation with the target (non warships).
   eSS_FormateStart,
   eSS_Formate,

   // Attack the target ship.
   eSS_AttackStart,
   eSS_Attack,
   eSS_AttackNewTarget,

   // Run to nearest known neutral or better station.
   eSS_FleeStart,
   eSS_Flee,

   // Dock to target
   eSS_DockStart,
   eSS_Dock,

   // Undock if possible 
   eSS_Undock,

   // Dock to a station cargo dock, locks down for cargo transfer
   eSS_CargoDockStart,
   eSS_CargoDock,

   // Loads one or more pods. Waits for completion.
   eSS_LoadPodStart,
   eSS_LoadPodWait,
   eSS_LoadPodStop,
   eSS_LoadPodOne,
   eSS_UnloadPodStart,
   eSS_UnloadPodWait,

   // Moves from ship to ship fueling.
   eSS_FuelShipStart,
   eSS_FuelShipWait,
   eSS_FuelFleetStart,
   eSS_FuelHalt,

   eSS_FuelDrainStart,
   eSS_FuelDrainWait,

   // Docks to nearest asteroid and begins science survey.
   eSS_ProspectStart,
   eSS_ProspectWait,
   eSS_Prospect,

   // Docks to nearest asteroid and begins mining.
   eSS_MineStart,
   eSS_MineWait,
   eSS_Mine,

   // Stops ship, deploys arrays and searches for asteroids/stations.
   eSS_LongScan,
   eSS_LongScanStop,
   eSS_LongScanDeploy,
   eSS_LongScanWait,
   eSS_LongScanHalt
};



prototype task evaluate_order(hship ship, ePlayerOrder order, hisim target);
prototype task wingman_watch(hship ship);


prototype accept_order(hship ship, bool debug_on);
prototype eShipState new_order_state(ePlayerOrder neworder);



prototype ePlayerOrder new_order(hship ship);
prototype set_new_order(hship ship, ePlayerOrder order);

prototype ePlayerOrder current_order(hship ship);
prototype set_current_order(hship ship, ePlayerOrder order);

prototype hisim current_target(hship ship);
prototype set_current_target(hship ship, hisim target);

prototype hisim new_target(hship ship);
prototype set_new_target(hship ship, hisim target);




// These belong in tsShip.pog
prototype bool is_warship(hship ship);

prototype bool is_tanker(hship ship);

prototype bool is_miner(hship ship);

prototype bool is_prospector(hship ship);

prototype bool is_long_range_scan(hship ship);

prototype hisim DockParent(hship ship);




// Debug tools.
prototype string state2string(eShipState state);

//prototype eShipState change_state(eShipState state, eShipState new_state, bool debug_on);

prototype eShipState change_state(hship ship, eShipState state, eShipState new_state, bool debug_on);





prototype bool DockPodSet(int group, set pods);

prototype bool station_known(int station_type);

prototype bool is_mine(hisim station);

prototype task mining_task(hship miner, hhabitat target);

prototype task prospecting_task(hship prospector, hhabitat target);

prototype bool is_valid_target(hisim target);

prototype bool is_valid_destination(hisim target);

prototype ePlayerOrder int2order(int order);


// These functions signal to the reputation code that the
// wingman is attacking a target intentionally. It is meant
// to keep from charging the player in unintentional attacks.

hisim OrderTarget(hship ship) {

   return iSim.Cast(Object.HandleProperty(ship,"gtCurrentTarget"));

}



SetOrderTarget(hship ship, hisim target) {

   Object.AddHandleProperty(ship,"gtCurrentTarget", target);

}


CurrentOrder(hship ship)
{
   Object.IntProperty(ship,"gtCurrentOrder");
}



GiveOrder(hship ship, ePlayerOrder order, hisim target)
{

   Task.Detach(start evaluate_order(ship, order, target));

}

// Begin the wingman task. If this is a restore, pass in old orders and target.
Start(hship ship, ePlayerOrder order, hisim target)
{
   set_current_order(ship, ePO_None);
   set_current_target(ship, none);

   set_new_order(ship, ePO_None);
   set_new_target(ship, none);

   Task.Detach(start evaluate_order(ship, order, target));

   Task.Detach(start wingman_watch(ship));

}

Save(hship ship)
{
   int id = Object.IDModulus( ship, 2147483647);
   string save_key = String.Join("tsWing",String.FromInt(id));
   hisim target;

   target = OrderTarget(ship);

   Global.CreateInt(String.Join(save_key,"order"), GA_Write, current_order(ship));
   Global.CreateString(String.Join(save_key,"target"), GA_Write, Sim.Name(target));
   Global.CreateString(String.Join(save_key,"system"), GA_Write, iSim.WorldName(target));
}

// Will restore the prior orders of the wing man. And try to restore the prior target.
Restore(hship ship)
{
   int id = Object.IDModulus( ship, 2147483647);
   string save_key = String.Join("tsWing",String.FromInt(id));
   hisim target;
   int order;
   string name, system;

   order = Global.Int(String.Join(save_key,"order"));
   name = Global.String(String.Join(save_key,"target"));
   system = Global.String(String.Join(save_key,"system"));

//   target = iSim.FindByNameInSystem(name, system);

//   Start(ship, int2order(order), target);
   Start(ship, int2order(order), none);
}

task evaluate_order(hship ship, ePlayerOrder order, hisim target)
{
   hfaction player_faction = tsFaction.PlayerFaction();
   hfaction empty_faction = tsFaction.EmptyFaction();
   ePlayerOrder porder_final;
   ePlayerOrder porder_current;
   hisim parent;
   hisim final_target;
   hship player = iShip.FindPlayerShip();


   debug {
      Debug.PrintString("tsWingman.evaluate_order ");
      Debug.PrintString(Text.Field(Sim.Name(ship), FT_Text));
      Debug.PrintString("\n");
   }


   // Some orders just ask for responses.
   switch (order) {
   case ePO_Respond:
      //iConversation.OneLiner( ship, "", "Group Here");
      return;
      break;
   case ePO_Status:
      iConversation.OneLiner( ship, "", "Sounding off");
      return;
      break;
   default:
      break;
   }

   // Test if we are out of system.
   // Tell player, ship out of system.
   if (iSim.ActiveWorld() != iSim.WorldName(ship)) {
      iConversation.OneLiner( ship, "", "Negative. Our ship is out of system");
      return;
   }


   // Reject if target does not exist, or is out of system.
   switch (order) {
   case ePO_Attack:
   case ePO_Escort:
   case ePO_Formate:
   case ePO_Dock:
   case ePO_FuelShip:
   case ePO_DrainFuel:
   case ePO_CollectPod:
   case ePO_Prospect:
   case ePO_Mine:
   
      if (none == target) {
         iConversation.OneLiner( ship, "", "Negative. No target");
         return;
      }

      if (iSim.ActiveWorld() != iSim.WorldName(target)) {
         iConversation.OneLiner( ship, "", "Negative. Target out of system");
         return;
      }
      break;
   default:
      break;
   }


   // Reject if the ship is docked to a larger ship.
   switch (order) {
   case ePO_Attack:
   case ePO_DefendMe:
   case ePO_Escort:
   case ePO_Formate:
   case ePO_FuelShip:
   case ePO_FuelFleet:
   case ePO_DrainFuel:
      if (DockParent(ship) != none) {
         iConversation.OneLiner( ship, "", "Negative. Our ship is docked");
         return;
      }
      break;
   case ePO_Dock:
   case ePO_Prospect:
   case ePO_Mine:
      // Reject if docked, and ordered to dock to a different target.
      parent = DockParent(ship);
      if (parent != none) {
         if (target != parent){
            iConversation.OneLiner( ship, "", "Negative. Our ship is docked");
            return;         
         }
      }
      break;
   default:
      break;
   }




   // Now reject all special cases where the target needs to be evaluated in detail.
   switch (order) {
   
   case ePO_Attack:
      if (!is_valid_target(target)) {
         iConversation.OneLiner( ship, "", "Negative. We cannot attack that target");
         return;
      }

      if (player_faction == iSim.Faction(iSim.Cast(target))) {
         iConversation.OneLiner( ship, "", "epo_refuse_player_ship_target");
         return;
      }

      // Do other ship checks here, like is the target the wrong faction etc.

      break;
   case ePO_Dock:

      if (!is_valid_target(target)) {
         iConversation.OneLiner( ship, "", "Negative. Invalid target");
         return;
      }

      break;
   case ePO_Escort:
   case ePO_Formate:
      // Allows Lpoints and waypoints.
      if (!is_valid_destination(target)) {
         iConversation.OneLiner( ship, "", "Negative. Invalid destination");
         return;
      }

      break;
   case ePO_FuelShip:
      if (!(TM_Ship & iSim.Type(target))) {
         iConversation.OneLiner( ship, "", "Negative. Target not a ship");
         return;
      }

      break;
   case ePO_DrainFuel:

      // The target must be a player fuel cargo pod or a ship of faction empty.
      if (TM_Ship & iSim.Type(target)) {
         if (empty_faction != iSim.Faction(target)) {
            iConversation.OneLiner(ship, "", "epo_refuse_not_empty_ship");
            return;
         }
      } else if (T_CargoPod == iSim.Type(target)) {
         if (CT_LiquifiedFuel != Object.IntProperty(target,"cargo")) {
            iConversation.OneLiner(ship, "", "epo_refuse_not_fuel_pod");
            return;
         }

         // Only dock player controlled pods.
         if (player_faction != iSim.Faction(target)) {
            iConversation.OneLiner(ship, "", "epo_not_player_pod");
            return;
         }

         // Don't dock sold pods.
         if (Object.BoolProperty(target, "md_epic_podsold"))
         {
            iConversation.OneLiner(ship, "", "epo_not_player_pod");
            return;
         }
      } else {
         iConversation.OneLiner(ship, "", "Negative. Target cannot supply fuel");
         return;
      }


      break;
   case ePO_CollectPod:

      // Only dock cargo pods.
      if (T_CargoPod != iSim.Type(target)) {
         iConversation.OneLiner(ship, "", "epo_not_cargo_pod");
         return;
      }

      // Don't dock sold pods.
      if (Object.BoolProperty(target, "md_epic_podsold"))
      {
         iConversation.OneLiner(ship, "", "epo_not_player_pod");
         return;
      }

      // Only dock player controlled pods.
      if (player_faction != iSim.Faction(target)) {
         iConversation.OneLiner(ship, "", "epo_not_player_pod");
         return;
      }
      break;

   case ePO_Mine:
      if (!is_mine(target)) {
         iConversation.OneLiner(ship, "", "epo_refuse_not_mine");
         return;
      }


      if (player_faction != iSim.Faction(target)) {
         iConversation.OneLiner(ship, "", "epo_refuse_not_player_mine");
         return;
      }
      break;

   case ePO_Prospect:
      if (!is_mine(target)) {
         iConversation.OneLiner(ship, "", "epo_refuse_not_mine");
         return;
      }


      if (empty_faction != iSim.Faction(target)) {
         iConversation.OneLiner(ship, "", "epo_refuse_claimed_asteroid");
         return;
      }
      break;

   default:
      break;
   }


   // Reject if the new order conflicts with the current order
   // Some orders are persisant. 
   switch (porder_current) {
   case ePO_CollectPods:
      switch (order) {
      case ePO_Halt:
         break;
      default:
         iConversation.OneLiner(ship, "", "Negative. Loading Cargo");
         return;
         break;
      }
      break;
   case ePO_CollectPod:
      switch (order) {
      case ePO_Halt:
         break;
      default:
         iConversation.OneLiner(ship, "", "Negative. Loading Cargo");
         return;
         break;
      }
      break;
   case ePO_FuelShip:
      switch (order) {
      case ePO_Halt:
         break;
      default:
         iConversation.OneLiner(ship, "", "Negative. Fueling Ship");
         return;
         break;
      }
      break;
   case ePO_FuelFleet:
      switch (order) {
      case ePO_Halt:
         break;
      default:
         iConversation.OneLiner(ship, "", "Negative. Fueling Fleet");
         return;
         break;
      }
      break;
   case ePO_DrainFuel:
      switch (order) {
      case ePO_Halt:
         break;
      default:
         iConversation.OneLiner(ship, "", "Negative. Draining Fuel");
         return;
         break;
      }
      break;
   default:
      break;
   }

   // The final check. See if the ship has the ability to execute the order.
   // Transport ships modify escort and defense orders into formate orders.
   porder_final = order;
   final_target = target;

   switch (order) {
   case ePO_Attack:
      if (!is_warship(ship)) {
         iConversation.OneLiner(ship, "", "Negative. This is not a warship I am flying!");
         return;
      }
      break;
   case ePO_DefendMe:
      if (!is_warship(ship)) {
         // Freighters just move to formation.
         porder_final = ePO_Formate;
         final_target = player;
      }else {
      }
      break;
   case ePO_Escort:
      // Freighters just move to formation.
      if (!is_warship(ship)) {
         porder_final = ePO_Formate;
      }
      break;
   case ePO_Dock:
      break;
   case ePO_Undock:
      break;
   case ePO_CollectPods:
      break;
   case ePO_CollectPod:
      break;
   case ePO_UndockPods:
      break;
   case ePO_FuelShip:
   case ePO_FuelFleet:
   case ePO_DrainFuel:
      if (!is_tanker(ship)) {
         iConversation.OneLiner(ship, "", "Negative. I am not a tanker");
         return;
      }
      break;
   case ePO_Prospect:
      if (!is_prospector(ship)) {
         iConversation.OneLiner(ship, "", "Negative. I am not a science ship");
         return;
      }
      break;
   case ePO_ScanSky:
      if (!is_long_range_scan(ship)) {
         iConversation.OneLiner(ship, "", "Negative. No long range sensors");
         return;
      }
      break;
   case ePO_Mine:
      if (!is_miner(ship)) {
         iConversation.OneLiner(ship, "", "Negative. I am not a mining rig");
         return;
      }
      break;
   default:
      break;
   }


   // Our command made it. Give the acknolegement.
   switch (porder_final) {
   case ePO_Halt:
      iConversation.OneLiner(ship, "", "Halting");
      break;
   case ePO_Attack:
      iConversation.OneLiner(ship, "", "Attacking your target");
      break;
   case ePO_DefendMe:
      iConversation.OneLiner(ship, "", "Defending you");
      break;
   case ePO_Escort:
      iConversation.OneLiner(ship, "", "Moving to escort");
      break;
   case ePO_Formate:
      iConversation.OneLiner(ship, "", "Moving into formation");
      break;
   case ePO_Dock:
      iConversation.OneLiner(ship, "", "Docking");
      break;
   case ePO_Undock:
      iConversation.OneLiner(ship, "", "Undocking");
      break;
   case ePO_CollectPods:
      iConversation.OneLiner(ship, "", "Loading pods");
      break;
   case ePO_CollectPod:
      iConversation.OneLiner(ship, "", "Loading target pod");
      break;
   case ePO_UndockPods:
      iConversation.OneLiner(ship, "", "Unloading all pods");
      break;
   case ePO_FuelShip:
      iConversation.OneLiner(ship, "", "Fueling ship");
      break;
   case ePO_FuelFleet:
      iConversation.OneLiner(ship, "", "Fueling fleet");
      break;
   case ePO_DrainFuel:
      iConversation.OneLiner(ship, "", "Draining fuel pod");
      break;
   case ePO_Prospect:
      iConversation.OneLiner(ship, "", "Science ship going for asteroid");
      break;
   case ePO_ScanSky:
      iConversation.OneLiner(ship, "", "Scanning for asteroids");
      break;
   case ePO_Mine:
      iConversation.OneLiner(ship, "", "Mining rig going for asteroid");
      break;
   default:
      break;
   }

   // Set the ships new orders, so the watch task can pick them up.

   atomic {
      set_new_order(ship, porder_final);
      set_new_target(ship, final_target);
   }
}



task wingman_watch(hship ship)
{
   eShipState wingman_state = eSS_None;
   eShipState next_state;
   bool debug_on = true;
   hship player;
   hisim target;
   ePlayerOrder neworder;
   hisim waypoint;


   while (1) {
      Task.Sleep(Task.Current(), 1.0);

      if (Sim.IsDead(ship)) {
         // we were killed, bail out.
         return;
      }

      neworder = new_order(ship);

      // Did we get attacked?
      // Have we told the player?

      // Have we started to flee?
      player = iShip.FindPlayerShip();

      switch (wingman_state) {
      case eSS_None:
         wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
         break;

      case eSS_NoPlayer:
         wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
         break;

      case eSS_Idle:
         // If we are not docked, and we are near the player
      // then
      // if we are a warship, enter into escort.
      // if we are a transport, enter into formate.

         if (none == player) {

            wingman_state = change_state(ship, wingman_state, eSS_NoPlayer, debug_on);

         }else if (none == DockParent(ship)) {

            if (Sim.DistanceBetween(player, ship) < 200km) {
               if (is_warship(ship)) {
                  set_current_order(ship, ePO_Escort);
                  set_current_target(ship, player);
                  wingman_state = change_state(ship, wingman_state, eSS_EscortStart, debug_on);
               }else {
                  set_current_order(ship, ePO_Formate);
                  set_current_target(ship, player);
                  wingman_state = change_state(ship, wingman_state, eSS_FormateStart, debug_on);
               }
            }

         }
         break;

      case eSS_HaltStart:
         // Force the ship to stop moving. This will bring it back to the place the player ordered 
         // the halt action.
         waypoint = iSim.Cast(Sim.Create("ini:/sims/nav/waypoint","halt_point"));
         Sim.PlaceAt(waypoint, ship);
         Task.Sleep(Task.Current(), 0.1);
         iAI.PurgeOrders(ship);
         iAI.GiveFormateOrder(ship, 
                              waypoint,
                              0,
                              0,
                              0);

         wingman_state = change_state(ship, wingman_state, eSS_HaltWait, debug_on);
         break;
      case eSS_HaltWait:
         // Wait here for any other order.
        // We have a new order. Change.
         if (neworder != ePO_None) {

            accept_order(ship, debug_on);
            next_state = new_order_state(neworder);
            wingman_state = change_state(ship, wingman_state, next_state, debug_on);

            // Clean up the halt waypoint.
            Sim.Destroy(waypoint);

         }
         break;


      case eSS_EscortStart:
         target = current_target(ship);

         if (none != target ) {
            // If we get a new order, break off and do it.
            iAI.PurgeOrders(ship);
         
            iAI.GiveEscortOrder(ship, 
                                target,
                                tFormation.Xpos(ship),
                                tFormation.Ypos(ship),
                                tFormation.Zpos(ship),
                                50km);

            wingman_state = change_state(ship, wingman_state, eSS_Escort, debug_on);
         }else {
            wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
         }
         break;

      case eSS_Escort:
         // We have a new order. Change.
         if (neworder != ePO_None) {

            accept_order(ship, debug_on);
            next_state = new_order_state(neworder);
            wingman_state = change_state(ship, wingman_state, next_state, debug_on);

         }

         break;

      case eSS_FormateStart:
         target = current_target(ship);

         if (none != target ) {
            // If we get a new order, break off and do it.
            iAI.PurgeOrders(ship);
         
            iAI.GiveFormateOrder(ship, 
                                target,
                                tFormation.Xpos(ship),
                                tFormation.Ypos(ship),
                                tFormation.Zpos(ship));
                           

            wingman_state = change_state(ship, wingman_state, eSS_Formate, debug_on);
         }else {
            wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
         }
         break;
      case eSS_Formate:
        // We have a new order. Change.
         if (neworder != ePO_None) {

            accept_order(ship, debug_on);
            next_state = new_order_state(neworder);
            wingman_state = change_state(ship, wingman_state, next_state, debug_on);

         }
         break;
      case eSS_Attack:
         // If we get a new order, take it.

         // Watch our target, if they flee and get too far
         // pick a new target.
         break;

      case eSS_AttackStart:
         // Go after the target. If that one no longer exists, 
         // pick another.
         break;

      case eSS_AttackNewTarget:
         // Pick a new hostile target near the player. If 
         // no targets, change orders back to escort.
         break;

      case eSS_FleeStart:
         // Ok, were damaged. Pick the closest neutral or better
         // station that we can flee towards. Empty is fine.
         break;

      case eSS_Flee:
         // We just flee till we reach our destination. No looking back.
         // When we get there, go to formate.
         // If we time out (10 min or so) then go to formate.
         // (possibly engine dead or something).
         break;

      case eSS_DockStart:
         target = current_target(ship);

         if (none != target) {

            iAI.PurgeOrders(ship);
            iAI.GiveDockOrder(ship, target);
            wingman_state = change_state(ship, wingman_state, eSS_Dock, debug_on);

         }else {

            wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);

         }
         break;

      case eSS_Dock:
         // Wait in this state for an undock order.
         if (neworder == ePO_Undock) {
            accept_order(ship, debug_on);
            next_state = new_order_state(neworder);
            wingman_state = change_state(ship, wingman_state, next_state, debug_on);
         }
         break;

      case eSS_Undock:
         // Undock from whatever we are docked onto, go to idle order.
         iShip.UndockSelf(ship);      
         iAI.PurgeOrders(ship);
         wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
         break;

      case eSS_LoadPodWait:
         // Wait for our list of pods to dock.
         // If they are done, then tell the player.
         // Formate to the player, remove the waypoint.
         // If we are told to halt, go to load pod stop.
         break;

      case eSS_LoadPodStart:
         // Drop a waypoint and formate on it.
         // Look for pods and grab up as many as we can.
         break;

      case eSS_LoadPodStop:
         // Halt any remaining pods.
         // Formate the player.
         // Remove the waypoint. 
         break;

      case eSS_FuelShipStart:
         // If the target is a ship that is low on fuel
         // Do a move order to the ship, and go to fuel ship wait.
         break;

      case eSS_FuelShipWait:
         // Once we move close to the ship, transfer fuel.
         // If fuel fleet order, go to fuel fleet start.
         // If given a halt order, go to formate player.
         break;

      case eSS_FuelFleetStart:
         // Pick the nearest player ship that is low on fuel.
         // Do a move order to the ship. go to fuel ship wait.
         break;

      default:
         // Should not be here, change state to eSS_None.
         wingman_state = change_state(ship, wingman_state, eSS_None, debug_on);
         break;

      }
   }
}


// Converts player orders into starting states.
eShipState new_order_state(ePlayerOrder neworder)
{

   switch (neworder) {
   case ePO_Halt:
      return eSS_HaltStart;
      break;
   case ePO_Attack:
      return eSS_AttackStart;
      break;
   case ePO_DefendMe:
      return eSS_EscortStart;
      break;
   case ePO_Escort:
      return eSS_EscortStart;
      break;
   case ePO_Formate:
      return eSS_FormateStart;
      break;
   case ePO_Dock:
      return eSS_DockStart;
      break;
   case ePO_Undock:
      return eSS_Undock;
      break;
   case ePO_CollectPods:
      return eSS_LoadPodStart;
      break;
   case ePO_CollectPod:
      return eSS_LoadPodOne;
      break;
   case ePO_UndockPods:
      return eSS_UnloadPodStart;
      break;
   case ePO_FuelShip:
      return eSS_FuelShipStart;
      break;
   case ePO_FuelFleet:
      return eSS_FuelFleetStart;
      break;
   case ePO_DrainFuel:
      return eSS_FuelDrainStart;
      break;
   case ePO_Prospect:
      return eSS_ProspectStart;
      break;
   case ePO_ScanSky:
      return eSS_LongScan;
      break;
   case ePO_Mine:
      return eSS_MineStart;
      break;
   default:
      break;
   }

   // Missed one. Restart the ship. 
   return eSS_None;
}



ePlayerOrder new_order(hship ship)
{
   return int2order(Object.IntProperty(ship,"gtNewOrder"));
}

set_new_order(hship ship, ePlayerOrder order)
{
   Object.AddIntProperty(ship,"gtNewOrder", order);
}



ePlayerOrder current_order(hship ship)
{
   return int2order(Object.IntProperty(ship,"gtCurrentOrder"));
}

set_current_order(hship ship, ePlayerOrder order)
{
   Object.AddIntProperty(ship,"gtCurrentOrder", order);
}


hisim current_target(hship ship)
{
   return iSim.Cast(Object.HandleProperty(ship,"gtCurrentTarget"));
}

set_current_target(hship ship, hisim target)
{
   Object.AddHandleProperty(ship,"gtCurrentTarget", target);
}


hisim new_target(hship ship)
{
   return iSim.Cast(Object.HandleProperty(ship,"gtNewTarget"));
}

set_new_target(hship ship, hisim target)
{
   Object.AddHandleProperty(ship,"gtNewTarget", target);
}




accept_order(hship ship, bool debug_on)
{
   atomic {
      // Accept the new order as the ships current order.
      set_current_target(ship, new_target(ship));

      set_current_order(ship, new_order(ship));

      // Clear the new order flag.
      set_new_order(ship, ePO_None);
   }
}

eShipState change_state(hship ship, eShipState state, eShipState new_state, bool debug_on)
{
   debug {
      if (debug_on) {
         Debug.PrintString(Text.Field(Sim.Name(ship),FT_Text));
         Debug.PrintString(" change ");
         Debug.PrintString(state2string(state));
         Debug.PrintString("->");
         Debug.PrintString(state2string(new_state));
         Debug.PrintString("\n");

      }
   }

   return new_state;
}




string state2string(eShipState state)
{
   switch (state) {
   case eSS_None:   
      return "eSS_None";
      break;
   case eSS_Idle:
      return "eSS_Idle";
      break;

   case eSS_HaltStart:   
      return "eSS_HaltStart";
      break;
   case eSS_HaltWait:   
      return "eSS_HaltWait";
      break;

   case eSS_EscortStart:   
      return "eSS_EscortStart";
      break;
   case eSS_Escort:   
      return "eSS_Escort";
      break;

   case eSS_FormateStart:   
      return "eSS_FormateStart";
      break;
   case eSS_Formate:   
      return "eSS_Formate";
      break;

   case eSS_AttackStart:   
      return "eSS_AttackStart";
      break;
   case eSS_Attack:   
      return "eSS_Attack";
      break;
   case eSS_AttackNewTarget:   
      return "eSS_AttackNewTarget";
      break;

   case eSS_FleeStart:   
      return "eSS_FleeStart";
      break;
   case eSS_Flee:   
      return "eSS_Flee";
      break;

   case eSS_DockStart:   
      return "eSS_DockStart";
      break;
   case eSS_Dock:   
      return "eSS_Dock";
      break;

   case eSS_Undock:   
      return "eSS_Undock";
      break;

   case eSS_CargoDockStart:   
      return "eSS_CargoDockStart";
      break;
   case eSS_CargoDock:   
      return "eSS_CargoDock";
      break;

   case eSS_LoadPodStart:   
      return "eSS_LoadPodStart";
      break;
   case eSS_LoadPodWait:   
      return "eSS_LoadPodWait";
      break;
   case eSS_LoadPodStop:   
      return "eSS_LoadPodStop";
      break;
   case eSS_LoadPodOne:   
      return "eSS_LoadPodOne";
      break;

   case eSS_UnloadPodStart:   
      return "eSS_UnloadPodStart";
      break;
   case eSS_UnloadPodWait:   
      return "eSS_UnloadPodWait";
      break;

   case eSS_FuelShipStart:   
      return "eSS_FuelShipStart";
      break;
   case eSS_FuelShipWait:   
      return "eSS_FuelShipWait";
      break;
   case eSS_FuelFleetStart:   
      return "eSS_FuelFleetStart";
      break;
   case eSS_FuelHalt:   
      return "eSS_FuelHalt";
      break;

   case eSS_FuelDrainStart:   
      return "eSS_FuelDrainStart";
      break;
   case eSS_FuelDrainWait:   
      return "eSS_FuelDrainWait";
      break;

   case eSS_ProspectStart:   
      return "eSS_ProspectStart";
      break;
   case eSS_ProspectWait:   
      return "eSS_ProspectWait";
      break;
   case eSS_Prospect:   
      return "eSS_Prospect";
      break;

   case eSS_MineStart:   
      return "eSS_MineStart";
      break;
   case eSS_MineWait:   
      return "eSS_MineWait";
      break;
   case eSS_Mine:   
      return "eSS_Mine";
      break;

   case eSS_LongScan:
      return "eSS_LongScan";
      break;
   case eSS_LongScanStop:   
      return "eSS_LongScanStop";
      break;
   case eSS_LongScanDeploy:   
      return "eSS_LongScanDeploy";
      break;
   case eSS_LongScanWait:   
      return "eSS_LongScanWait";
      break;
  case eSS_LongScanHalt:   
      return "eSS_LongScanHalt";
      break;

   default:
      break;
   }

   return "eSS_Invalid";

}


ePlayerOrder int2order(int order)
{
   return order;
}




int PriorOrder(hship ship)
{
   return Object.IntProperty(ship,"gt_prior_order");
}

SetPriorOrder(hship ship, int order_type)
{
   Object.AddIntProperty(ship,"gt_prior_order", order_type);
}

bool is_long_range_scan(hship ship)
{
   return (Object.IntProperty(ship,"scan_range") >= 1);
}

bool is_prospector(hship ship)
{
   return (Object.IntProperty(ship,"prospector") >= 1);
}

bool is_miner(hship ship)
{
   return (Object.IntProperty(ship,"miner") >= 1);
}

bool is_tanker(hship ship)
{
   return (Object.IntProperty(ship,"tanker") >= 1);
}

// If this ship is docked to a larger ship, return that ship.
// Move this code to tsShip.
hisim DockParent(hship ship)
{
   return iSim.Cast(Sim.Parent(ship));
}


// Is this an armed ship? Transports and utility vessels are excluded.
bool is_warship(hship ship)
{
   if (iSim.Type(ship) & (T_Fighter | T_Tug | T_Patcom | T_Interceptor | T_Corvette | T_Destroyer | T_Cruiser | T_Carrier)) {
      return true;
   }
   return false;
}


// Don't allow attacks on planets, nebula or other non-ship or station type items.
bool is_valid_target(hisim target)
{
   if (iSim.Type(target) & (TM_Ship | T_Asteroid | T_CargoPod | T_Gunstar | T_Station | T_BioBomber)) {
      return true;
   }

   return false;
}

// Don't allow approch orders to stars or planets or missiles or other odd items.
bool is_valid_destination(hisim target)
{
   if (iSim.Type(target) & (TM_Ship | T_Waypoint | T_LagrangePoint | T_Asteroid | T_CargoPod
                            | T_Gunstar | T_Station | T_BioBomber)) {
      return true;
   }

   return false;
}


bool station_known(int station_type) {

   switch (station_type) {
   case ept_PirateBase :
   case ept_PirateCove :
   case ept_PirateOutpost:
   case ept_GangsterHideout:
      return false;
      break;
   default:
      break;
   }

   return true;
} 



//bool is_mine(hhabitat station) {
bool is_mine(hisim station) {
   int station_type;


   if (T_Station != iSim.Type(station)) {
      return false;
   }

   station_type = tLProduction.GetType(station);

   switch (station_type) {
   case HT_WaterMine:
   case HT_OrganicsMine:
   case HT_InorganicsMine:
   case HT_BiomassMine:
   case HT_CommonMetalsMine:
   case HT_RareMetalsMine:
   case HT_ExoticMetalsMine:
   case HT_RadioactivesMine:
   case HT_FusionableGasesMine:
   case HT_NeutroniumMine:
      return true;
      break;
   default:
      break;
   }

   return false;
}


/*    
THIS MOD IS NOT MADE, DISTRIBUTED, OR SUPPORTED BY INFOGRAMES
OR PARTICLE SYSTEMS LTD. 

ELEMENTS TM & (C) INFOGRAMES AND PARTICLE SYSTEMS LTD.
*/
