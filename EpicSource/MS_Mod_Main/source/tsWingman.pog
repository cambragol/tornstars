//*******************************************************************************************/
//
// tsWingman.pog
//
// This file implements a wingman control task. It takes orders from the player and gives
// feedback to the player when orders are complete, or have gone wrong.
// 
// Each wingman becomes a state driven AI entity. This forms a new layer between the PS AI
// interface and the player orders.
//
// November 2006, Jon Freise
//******************************************************************************************/

package tsWingman;

// Imports
uses	Sim,
		iShip,
		iSim,
		iPilotSetup,
		Debug,
		Global,
		GUI,
		iDirector,
		iGUI,
		iHUD,
		iHabitat,
		iMapEntity,
		INIFile,
		Input,
		List,
		Object,
		String,
		Task,
		Text,
		iUtilities,
		iCargo,
		iInventory,
		iComms,
		iConversation,
		iAi,
		Math,
		CargoTypes,
		
		tsShipEnum,
		tsShip,
		tFormation,
		tPodUtil,
		tsFaction,
		tStationEnum,
		tStation,
		tLProduction,
		tMegaTrucking,
		tStationFilter;


// Exports
provides GiveOrder,
         Start,
         OrderTarget,
         CurrentOrder,
         Save,
         Restore;



// These are a series of states that implement orders.
enum eShipState {
   eSS_None,
   eSS_NoPlayer,
   eSS_Idle,
   eSS_NoFuel,

   eSS_HaltStart,
   eSS_HaltWait,

   // Defensive escort of the the target (warships).
   eSS_EscortStart,   
   eSS_Escort,

   // Move into formation with the target (non warships).
   eSS_FormateStart,
   eSS_Formate,

   // Attack the target ship.
   eSS_AttackStart,
   eSS_Attack,
   eSS_AttackNewTarget,

   // Run to nearest known neutral or better station.
   eSS_FleeStart,
   eSS_Flee,

   // Dock to target
   eSS_DockStart,
   eSS_Dock,

   // Undock if possible 
   eSS_Undock,

   // Dock to a station cargo dock, locks down for cargo transfer
   eSS_CargoDockStart,
   eSS_CargoDock,

   // Loads one or more pods. Waits for completion.
   eSS_LoadPodStart,
   eSS_LoadPodWait,
   eSS_LoadPodStop,
   eSS_LoadPodOne,
   eSS_UnloadPodStart,
   eSS_UnloadPodWait,

   // Moves from ship to ship fueling.
   eSS_FuelShipStart,
   eSS_FuelShipWait,
   eSS_FuelFleetWait,
   eSS_FuelFleetStart,
   eSS_FuelHalt,

   eSS_FuelDrainStart,
   eSS_FuelDrainWait,

   // Docks to nearest asteroid and begins science survey.
   eSS_ProspectStart,
   eSS_ProspectWait,
   eSS_Prospect,

   // Docks to nearest asteroid and begins mining.
   eSS_MineStart,
   eSS_MineWait,
   eSS_Mine,

   // Stops ship, deploys arrays and searches for asteroids/stations.
   eSS_LongScanStart,
   eSS_LongScanStop,
   eSS_LongScanDeploy,
   eSS_LongScanWait
};


// Prototypes
prototype task evaluate_order(hship ship, ePlayerOrder order, hisim target, bool restored_order);
prototype task wingman_watch(hship ship);


prototype accept_order(hship ship, bool debug_on);
prototype eShipState new_order_state(ePlayerOrder neworder);



prototype ePlayerOrder new_order(hship ship);
prototype set_new_order(hship ship, ePlayerOrder order);

prototype ePlayerOrder current_order(hship ship);
prototype set_current_order(hship ship, ePlayerOrder order);

prototype hisim current_target(hship ship);
prototype set_current_target(hship ship, hisim target);

prototype hisim new_target(hship ship);
prototype set_new_target(hship ship, hisim target);

prototype set_ship_state(hship ship, eShipState status);
prototype eShipState ship_state(hship ship);


prototype bool tanker_fill_ship(hship tanker, hship target);
prototype bool tanker_empty_ship(hship tanker, hship target);


prototype set player_fleet();



// Debug tools.
prototype string state2string(eShipState state);

//prototype eShipState change_state(eShipState state, eShipState new_state, bool debug_on);

prototype eShipState change_state(hship ship, eShipState state, eShipState new_state, bool debug_on);



prototype bool DockPodSet(int group, set pods);
prototype bool station_known(int station_type);
prototype bool is_mine(hisim station);
prototype task mining_task(hship miner, hhabitat target);
prototype task prospecting_task(hship prospector, hhabitat target);
prototype bool is_valid_target(hisim target);
prototype bool is_valid_destination(hisim target);
prototype ePlayerOrder int2order(int order);
prototype eShipState int2state (int state);


// These functions signal to the reputation code that the
// wingman is attacking a target intentionally. It is meant
// to keep from charging the player in unintentional attacks.
//[of]:hisim OrderTarget(hship ship)
hisim OrderTarget(hship ship)
{

   return iSim.Cast(Object.HandleProperty(ship,"gtCurrentTarget"));

}
//[cf]


//[of]:SetOrderTarget(hship ship, hisim target)
SetOrderTarget(hship ship, hisim target)
{

   Object.AddHandleProperty(ship,"gtCurrentTarget", target);

}
//[cf]


// External interface to a ships current order.
//[of]:ePlayerOrder CurrentOrder(hship ship)
ePlayerOrder CurrentOrder(hship ship)
{
   return current_order(ship);
}
//[cf]


//[of]:GiveOrder(hship ship, ePlayerOrder order, hisim target)
GiveOrder(hship ship, ePlayerOrder order, hisim target)
{

   Task.Detach(start evaluate_order(ship, order, target, false));

}
//[cf]


// Begin the wingman task. If this is a restore, pass in old orders and target.
//[of]:Start(hship ship, ePlayerOrder order, hisim target)
Start(hship ship, ePlayerOrder order, hisim target)
{
   set_current_order(ship, ePO_None);
   set_current_target(ship, none);

   set_new_order(ship, ePO_None);
   set_new_target(ship, none);

   Task.Detach(start evaluate_order(ship, order, target, true));

   Task.Detach(start wingman_watch(ship));

}
//[cf]

//[of]:Save(hship ship)
Save(hship ship)
{
   int id = Object.IDModulus( ship, 2147483647);
   string save_key = String.Join("tsWing",String.FromInt(id));
   hisim target;

   target = OrderTarget(ship);

   Global.CreateInt(String.Join(save_key,"order"), GA_Write, current_order(ship));
   Global.CreateString(String.Join(save_key,"target"), GA_Write, Sim.Name(target));
   Global.CreateString(String.Join(save_key,"system"), GA_Write, iSim.WorldName(target));
}
//[cf]


// Will restore the saved orders of the wing man. And try to restore the saved target.
//[of]:Restore(hship ship)
Restore(hship ship)
{
   int id = tsShip.SaveId(ship);
   string save_key = String.Join("tsWing",String.FromInt(id));
   hisim target;
   int order;
   string name, system;

   order = Global.Int(String.Join(save_key,"order"));
   name = Global.String(String.Join(save_key,"target"));
   system = Global.String(String.Join(save_key,"system"));

   target = iSim.FindByNameInSystem(name, system);

   Start(ship, int2order(order), target);
}
//[cf]


//[of]:task evaluate_order(hship ship, ePlayerOrder order, hisim target, bool restored_order)
task evaluate_order(hship ship, ePlayerOrder order, hisim target, bool restored_order)
{
   hfaction player_faction = tsFaction.PlayerFaction();
   hfaction empty_faction = tsFaction.EmptyFaction();
   ePlayerOrder porder_final;
   hisim parent;
   hisim final_target;
   hship player = iShip.FindPlayerShip();


   debug {
      Debug.PrintString("tsWingman.evaluate_order ");
      Debug.PrintString(Text.Field(Sim.Name(ship), FT_Text));
      Debug.PrintString("\n");
   }


   // Some orders just ask for responses.
   switch (order) {
   case ePO_None:
      // If we get a none, order, just return.
      // This happens when ships are newly started.
      return;
      break;
   case ePO_Respond:
      iConversation.OneLiner( ship, "", "epo_group_ack");
      return;
      break;
   case ePO_Status:
      if (ship_state(ship) == eSS_NoFuel) {
         iConversation.OneLiner(ship, "", "epo_status_no_fuel");
      }else {
         iConversation.OneLiner( ship, "", "epo_status_ack");
      }
      return;
      break;
   default:
      break;
   }


   // We block the player from giving new orders to ships out of the
   // system where the player is located. Allow restored orders
   // to be put back no matter where the ship is located.
   if (!restored_order) {
      // Test if we are out of system.
      // Tell player, ship out of system.
      if (iSim.ActiveWorld() != iSim.WorldName(ship)) {
         iConversation.OneLiner( ship, "", "epo_refuse_out_of_system");
         return;
      }
   }

   // We block commands to ships that have no fuel supply. Tell the player.
   if (ship_state(ship) == eSS_NoFuel) {
      iConversation.OneLiner(ship, "", "epo_status_no_fuel");
   }


   // Reject if target does not exist, or is out of system.
   switch (order) {
   case ePO_Attack:
   case ePO_Escort:
   case ePO_Formate:
   case ePO_Dock:
   case ePO_FuelShip:
   case ePO_DrainFuel:
   case ePO_CollectPod:
      if (none == target) {
         iConversation.OneLiner( ship, "", "epo_refuse_no_target");
         return;
      }

      if (iSim.WorldName(ship) != iSim.WorldName(target)) {
         iConversation.OneLiner( ship, "", "epo_refuse_target_far");
         return;
      }
      break;
   default:
      break;
   }


   // Reject if the ship is docked to a larger ship.
   switch (order) {
   case ePO_Attack:
   case ePO_DefendMe:
   case ePO_Escort:
   case ePO_Formate:
   case ePO_FuelShip:
   case ePO_FuelFleet:
   case ePO_DrainFuel:
   case ePO_CollectPod:
   case ePO_CollectAllPods:
   case ePO_UndockPods:
   case ePO_ScanSky:
      if (tsShip.DockParent(ship) != none) {
         iConversation.OneLiner( ship, "", "epo_refuse_ship_docked");
         return;
      }
      break;
   case ePO_Dock:
   case ePO_Prospect:
   case ePO_Mine:
      // Reject if docked, and ordered to dock to a different target.
      parent = tsShip.DockParent(ship);
      if (parent != none) {
         if (target != parent){
            iConversation.OneLiner( ship, "", "epo_refuse_ship_docked");
            return;         
         }
      }
      break;
   default:
      break;
   }


   // Reject if the new order conflicts with the current order
   // Some orders are persisant. 
   switch (current_order(ship)) {
   case ePO_CollectAllPods:
      switch (order) {
      case ePO_Halt:
         //only allow a halt order.
         break;
      default:
         iConversation.OneLiner(ship, "", "epo_refuse_loading_cargo");
         return;
         break;
      }
      break;
   case ePO_CollectPod:
      switch (order) {
      case ePO_Halt:
         //only allow a halt order.
         break;
      default:
         iConversation.OneLiner(ship, "", "epo_refuse_loading_cargo");
         return;
         break;
      }
      break;
   case ePO_FuelShip:
      switch (order) {
      case ePO_Halt:
         //only allow a halt order.
         break;
      default:
         iConversation.OneLiner(ship, "", "epo_refuse_fueling");
         return;
         break;
      }
      break;
   case ePO_FuelFleet:
      switch (order) {
      case ePO_Halt:
         //only allow a halt order.
         break;
      default:
         iConversation.OneLiner(ship, "", "epo_refuse_fueling");
         return;
         break;
      }
      break;
   case ePO_DrainFuel:
      switch (order) {
      case ePO_Halt:
         //only allow a halt order.
         break;
      default:
         iConversation.OneLiner(ship, "", "epo_refuse_fueling");
         return;
         break;
      }
      break;
   default:
      break;
   }


   // This allows the type of ship to change the order slightly.
   // This happens when transports are ordered to escort.
   // Also allows some commands to pick the target. Such as mining.
   final_target = target;
   porder_final = order;

   // Our command made it. Send it to the ship.
   // When it switches to the command, it will acknowledge.
   switch (order) {
   case ePO_Halt:

      break;
   case ePO_Attack:
      if (!tsShip.IsWarship(ship)) {
         iConversation.OneLiner(ship, "", "epo_refuse_not_warship");
         return;
      }

      if (!is_valid_target(target)) {
         iConversation.OneLiner( ship, "", "epo_refuse_no_target");
         return;
      }

      // Don't allow self as target
      if (iSim.Cast(ship) == iSim.Cast(target)) {
         iConversation.OneLiner( ship, "", "epo_refuse_no_target");
         return;
      }

      if (player_faction == iSim.Faction(iSim.Cast(target))) {
         iConversation.OneLiner( ship, "", "epo_refuse_player_ship_target");
         return;
      }
      break;

   case ePO_DefendMe:
      final_target = player;

      // Freighters just move to formation.
      if (!tsShip.IsWarship(ship)) {
         porder_final = ePO_Formate;
      }
      break;

   case ePO_Escort:
      // Allows Lpoints and waypoints.
      if (!is_valid_destination(target)) {
         iConversation.OneLiner( ship, "", "epo_refuse_no_target");
         return;
      }

      // Don't allow self as target
      if (iSim.Cast(ship) == iSim.Cast(target)) {
         iConversation.OneLiner( ship, "", "epo_refuse_no_target");
         return;
      }

      // Freighters just move to formation.
      if (!tsShip.IsWarship(ship)) {
         porder_final = ePO_Formate;
      }
      break;

   case ePO_Formate:
      // Allows Lpoints and waypoints.
      if (!is_valid_destination(target)) {
         iConversation.OneLiner( ship, "", "epo_refuse_no_target");
         return;
      }

      // Don't allow self as target
      if (iSim.Cast(ship) == iSim.Cast(target)) {
         iConversation.OneLiner( ship, "", "epo_refuse_no_target");
         return;
      }

      break;

   case ePO_Dock:
      if (!is_valid_target(target)) {
         iConversation.OneLiner( ship, "", "epo_refuse_no_target");
         return;
      }

      // Don't allow self as target
      if (iSim.Cast(ship) == iSim.Cast(target)) {
         iConversation.OneLiner( ship, "", "epo_refuse_no_target");
         return;
      }

      break;

   case ePO_Undock:
      break;

   case ePO_CollectAllPods:
      // Ack done in wingman watch
      //iConversation.OneLiner(ship, "", "epo_load_cargo_pods_ack");
      break;

   case ePO_CollectPod:
      // Only dock cargo pods.
      if (T_CargoPod != iSim.Type(target)) {
         iConversation.OneLiner(ship, "", "epo_not_cargo_pod");
         return;
      }

      // Don't dock sold pods.
      if (Object.BoolProperty(target, "md_epic_podsold"))
      {
         iConversation.OneLiner(ship, "", "epo_not_player_pod");
         return;
      }

      // Only dock player controlled pods.
      if (player_faction != iSim.Faction(target)) {
         iConversation.OneLiner(ship, "", "epo_not_player_pod");
         return;
      }


      break;

   case ePO_UndockPods:
      iConversation.OneLiner(ship, "", "epo_unload_pods_ack");
      break;

   case ePO_FuelShip:
      if (!tsShip.IsTanker(ship)) {
         iConversation.OneLiner(ship, "", "epo_refuse_not_tanker");
         return;
      }

      if (!(TM_Ship & iSim.Type(target))) {
         iConversation.OneLiner( ship, "", "epo_refuse_fuel_only_ship");
         return;
      }

      // Don't allow self as target
      if (iSim.Cast(ship) == iSim.Cast(target)) {
         iConversation.OneLiner( ship, "", "epo_refuse_no_target");
         return;
      }

      break;

   case ePO_FuelFleet:
      if (!tsShip.IsTanker(ship)) {
         iConversation.OneLiner(ship, "", "epo_refuse_not_tanker");
         return;
      }


      break;
   case ePO_DrainFuel:
      if (!tsShip.IsTanker(ship)) {
         iConversation.OneLiner(ship, "", "epo_refuse_not_tanker");
         return;
      }
      // The target must be a player fuel cargo pod or a ship of faction empty.
      if (TM_Ship & iSim.Type(target)) {
         if (empty_faction != iSim.Faction(target)) {
            iConversation.OneLiner(ship, "", "epo_refuse_not_empty_ship");
            return;
         }
      } else if (T_CargoPod == iSim.Type(target)) {
         if (CT_LiquifiedFuel != Object.IntProperty(target,"cargo")) {
            iConversation.OneLiner(ship, "", "epo_refuse_not_fuel_pod");
            return;
         }

         // Only dock player controlled pods.
         if (player_faction != iSim.Faction(target)) {
            iConversation.OneLiner(ship, "", "epo_not_player_pod");
            return;
         }

         // Don't dock sold pods.
         if (Object.BoolProperty(target, "md_epic_podsold"))
         {
            iConversation.OneLiner(ship, "", "epo_not_player_pod");
            return;
         }
      } else {
         iConversation.OneLiner(ship, "", "epo_refuse_not_fuel_pod");
         return;
      }


      break;
   case ePO_Prospect:

      if (!tsShip.IsProspector(ship)) {
         iConversation.OneLiner(ship, "", "epo_refuse_not_prospector");
         return;
      }

      final_target = iHabitat.Nearest(iSim.SimsInRadius(ship, 200km, T_Station), ship);

      if (none == final_target) {
         iConversation.OneLiner(ship, "", "epo_refuse_no_mine_near");
         return;
      }

      if (!is_mine(final_target)) {
         iConversation.OneLiner(ship, "", "epo_refuse_not_mine");
         return;
      }

      if (empty_faction != iSim.Faction(final_target)) {
         iConversation.OneLiner(ship, "", "epo_refuse_claimed_asteroid");
         return;
      }

      break;
   case ePO_ScanSky:
      if (!tsShip.IsLongRangeScan(ship)) {
         iConversation.OneLiner(ship, "", "epo_refuse_not_scan_ship");
         return;
      }

      break;
   case ePO_Mine:
      if (!tsShip.IsMiner(ship)) {
         iConversation.OneLiner(ship, "", "epo_refuse_not_mining_ship");
         return;
      }

      final_target = iHabitat.Nearest(iSim.SimsInRadius(ship, 200km, T_Station), ship);

      if (none == final_target) {
         iConversation.OneLiner(ship, "", "epo_refuse_no_mine_near");
         return;
      }

      if (!is_mine(final_target)) {
         iConversation.OneLiner(ship, "", "epo_refuse_not_mine");
         return;
      }

      if (player_faction != iSim.Faction(final_target)) {
         iConversation.OneLiner(ship, "", "epo_refuse_unclaimed_mine");
         return;
      }

      break;
   default:
      iConversation.OneLiner(ship, "", "epo_invalid_order");
      return;
      break;
   }


   // Set the ships new orders, so the watch task can pick them up.
   atomic {
      set_new_order(ship, porder_final);
      set_new_target(ship, final_target);
   }


   debug {
      Debug.PrintString("tsWingman.evaluate_order done");
      Debug.PrintString(Text.Field(Sim.Name(ship), FT_Text));
      Debug.PrintString("\n");
   }
}
//[cf]


//[of]:task wingman_watch(hship ship)
task wingman_watch(hship ship)
{
   eShipState wingman_state = eSS_None;
   eShipState next_state;
   bool debug_on = true;
   hfaction player_faction = tsFaction.PlayerFaction();
   hship player;
   hship pod;
   hisim target;
   hisim dock_target;
   hship target_ship;
   hhabitat station;
   ePlayerOrder neworder;
   hisim waypoint;
   int flee_timer, scan_timer;
   bool locked = false;
   bool filled = false;
   bool new_station = false;
   string response;
   list target_list, fuel_list, cargo_list;
   set cargo_set, empty_set, stations, nearby_locations;
   int i, total;

   while (1) {
      Task.Sleep(Task.Current(), 1.0);

      if (Sim.IsDead(ship)) {
         // we were killed, bail out.
         return;
      }

      player = iShip.FindPlayerShip();

      neworder = new_order(ship);
      if (ePO_None != neworder) {
         debug {
            Debug.PrintString("tsWingman.wingman_watch new order");
            Debug.PrintString(Text.Field(Sim.Name(ship), FT_Text));
            Debug.PrintString("\n");
         }
      }

      // If the player is more than half culling distance away, lock down the weapons systems.
      if (Sim.DistanceBetween(player, ship) > Global.Float("gt_distance_wakeup")) {
         if (false == locked) {
            // Pull ship out of the player combat group.
            Group.RemoveSim(Sim.Group(ship), ship);
            iShip.LockDownWeapons(ship);
            locked = true;
         }
      }else{
         if (true == locked) {
            // if the wingmans weapons were locked down, unlock them.
            iShip.WeaponTargetsFromContactList(ship);
            locked = false;
            Group.AddSim(Sim.Group(player), ship);
         }
      }

      // Did we get attacked?
      // Have we told the player?

      // Have we started to flee?
      if (OT_Flee == iAI.CurrentOrderType(ship)) {
         if (eSS_Flee != wingman_state) {
            wingman_state = change_state(ship, wingman_state, eSS_FleeStart, debug_on);
         }
      }

      if ((tsShip.Fuel(ship) < 1 ) && (wingman_state != eSS_NoFuel)) {
         iConversation.OneLiner(ship, "", "epo_status_no_fuel");
         wingman_state = change_state(ship, wingman_state, eSS_NoFuel, debug_on);
      }

      switch (wingman_state) {
      case eSS_None:
         wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
         break;

      case eSS_NoPlayer:
         wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
         break;

      case eSS_NoFuel:
         // Bring the ship to a stop. Halt it from executing any orders.
         iAI.PurgeOrders(ship);
         if (tsShip.Fuel(ship) > 1) {
            wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
         }
         break;

      case eSS_Idle:
         // If we are not docked, and we are near the player
         // then
         // if we are a warship, enter into escort.
         // if we are a transport, enter into formate.

         if (none == player) {

            wingman_state = change_state(ship, wingman_state, eSS_NoPlayer, debug_on);

         }else if (none == tsShip.DockParent(ship)) {

            if (Sim.DistanceBetween(player, ship) < 200km) {
               if (tsShip.IsWarship(ship)) {
                  atomic {
                     set_current_order(ship, ePO_Escort);
                     set_current_target(ship, player);
                  }
                  wingman_state = change_state(ship, wingman_state, eSS_EscortStart, debug_on);
               }else {
                  atomic {
                     set_current_order(ship, ePO_Formate);
                     set_current_target(ship, player);
                  }
                  wingman_state = change_state(ship, wingman_state, eSS_FormateStart, debug_on);
               }
            }
         }else if (neworder == ePO_Undock) {
            accept_order(ship, debug_on);
            next_state = new_order_state(neworder);
            wingman_state = change_state(ship, wingman_state, next_state, debug_on);
         }
         break;

      case eSS_HaltStart:
         iConversation.OneLiner(ship, "", "epo_halt_order_ack");
         // Force the ship to stop moving. This will bring it back to the place the player ordered 
         // the halt action.
         waypoint = iSim.Cast(Sim.Create("ini:/sims/nav/waypoint","halt_point"));
         Sim.PlaceAt(waypoint, ship);
         Task.Sleep(Task.Current(), 0.1);
         iAI.PurgeOrders(ship);
         iAI.GiveFormateOrder(ship, 
                              waypoint,
                              0,
                              0,
                              0);

         wingman_state = change_state(ship, wingman_state, eSS_HaltWait, debug_on);
         break;

      case eSS_HaltWait:
         // Wait here for any other order.
        // We have a new order. Change.
         if (new_order(ship) != ePO_None) {

            accept_order(ship, debug_on);
            next_state = new_order_state(current_order(ship));
            wingman_state = change_state(ship, wingman_state, next_state, debug_on);

            // Clean up the halt waypoint.
            Sim.Destroy(waypoint);

         }
         break;

      case eSS_EscortStart:
         target = current_target(ship);

         if (none != target ) {
            if (target == iSim.Cast(player)) {
               iConversation.OneLiner(ship, "", "epo_escort_player_ack");
            }else {
               iConversation.OneLiner(ship, "", "epo_escort_target_ack");
            }

            iAI.PurgeOrders(ship);

            iAI.GiveEscortOrder(ship, 
                                target,
                                tFormation.Xpos(ship),
                                tFormation.Ypos(ship),
                                tFormation.Zpos(ship),
                                20km);

            wingman_state = change_state(ship, wingman_state, eSS_Escort, debug_on);
         }else {
            wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
         }
         break;

      case eSS_FormateStart:
         target = current_target(ship);

         if (none != target ) {

            if (target == iSim.Cast(player)) {
               iConversation.OneLiner(ship, "", "epo_formate_player_ack");
            }else {
               iConversation.OneLiner(ship, "", "epo_formate_target_ack");
            }

            iAI.PurgeOrders(ship);
         
            iAI.GiveFormateOrder(ship, 
                                target,
                                tFormation.Xpos(ship),
                                tFormation.Ypos(ship),
                                tFormation.Zpos(ship));
                           

            wingman_state = change_state(ship, wingman_state, eSS_Formate, debug_on);
         }else {
            wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
         }
         break;

      case eSS_Escort:
      case eSS_Formate:
        // We have a new order. Change.
         if (new_order(ship) != ePO_None) {

            accept_order(ship, debug_on);
            next_state = new_order_state(current_order(ship));
            wingman_state = change_state(ship, wingman_state, next_state, debug_on);

         }
         break;


      case eSS_AttackStart:
         // Go after the target. 
         iConversation.OneLiner(ship, "", "epo_attack_target_ack");

         target = current_target(ship);

         if (player != iShip.Cast(target)){

            SetOrderTarget(ship, target);

            iAI.PurgeOrders(ship);
            iAI.GiveAttackOrder(ship, target);

            wingman_state = change_state(ship, wingman_state, eSS_Attack, debug_on);
         }else {
            debug Debug.PrintString("tsWingman.wingman_watch illegal target in attack_start\n");
            wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
         }
         break;

      case eSS_Attack:
         // If we get a new order, take it.
        // We have a new order. Change.
         target = current_target(ship);

         if (Sim.IsDead(target)) {
            // Job accomplished, return to player.
            wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
            set_current_target(ship, none);
         }else if (OT_Flee == iAI.CurrentOrderType(iShip.Cast(target))
                   || (Sim.DistanceBetween(player, ship) > 400km)) {
            // Break away, reformate with the player.
            wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
            set_current_target(ship, none);
         }else if (new_order(ship) != ePO_None) {
            accept_order(ship, debug_on);
            next_state = new_order_state(current_order(ship));
            wingman_state = change_state(ship, wingman_state, next_state, debug_on);
         }
         break;

      case eSS_FleeStart:
         // Ok, we are damaged. Pick the closest neutral or better
         // station that we can flee towards. Empty is fine.
         flee_timer = 2 * 60;

         // Pick a non-hostile station that is near.
         nearby_locations = iMapEntity.SystemHabitats();
         station = iHabitat.Nearest(nearby_locations, ship);
         Set.Remove(nearby_locations, station);

         // Only go to stations the player knows about.
         nearby_locations = tStationFilter.OnMapVisible(nearby_locations, true);

         // And those that are player friendly.
         station = iHabitat.Nearest(tStationFilter.OnGreaterFeeling(nearby_locations,
                                                                        player_faction, 
                                                                        -0.2), 
                                        ship);
         debug {
            Debug.PrintHandle(station);
            Debug.PrintString(" flee station target\n");
         }

         // If we could find a safe location, flee to it. Otherwise, just keep fleeing.
         if (none != station) {
            iAI.PurgeOrders(ship);
            iAI.GiveApproachOrderAdvanced( ship,
                                           station,
                                           75km,
                                           80km,
                                           true);
         }

         iConversation.OneLiner(ship, "", "epo_wingman_flees");

         wingman_state = change_state(ship, wingman_state, eSS_Flee, debug_on);
         break;

      case eSS_Flee:
         // We just flee till we reach our destination. No looking back.
         // When we get there, go to idle.
         // If we time out (10 min or so) then go to idle.
         // (possibly engine dead or something).
         --flee_timer;

         if ((OT_None == iAI.CurrentOrderType(ship)) || (flee_timer < 0)) {

            iShip.Attacked(ship);
            iAI.SetFleeFunction( ship, "" );
            wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
         }
         break;

      case eSS_DockStart:
         target = current_target(ship);

         if (none != target) {
            iConversation.OneLiner(ship, "", "epo_dock_target_ack");

            iAI.PurgeOrders(ship);
            iAI.GiveDockOrder(ship, target);
            dock_target = target;

            wingman_state = change_state(ship, wingman_state, eSS_Dock, debug_on);

         }else {

            wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);

         }
         break;

      case eSS_Dock:
         // Wait in this state for an undock order.
         if (neworder != ePO_None) {
            accept_order(ship, debug_on);
            next_state = new_order_state(neworder);
            wingman_state = change_state(ship, wingman_state, next_state, debug_on);
         }else if (OT_None == iAI.CurrentOrderType(ship)) {
            // If the order completes, go to idle.

            if (iSim.IsDockedTo(ship, dock_target)) {
               iConversation.OneLiner(ship, "", "epo_docking_complete");
            }
            wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
         }
         break;

      case eSS_Undock:
         iConversation.OneLiner(ship, "", "epo_undock_ack");
         // Undock from whatever we are docked onto, go to idle order.
         iAI.PurgeOrders(ship);
         iShip.UndockSelf(ship);      
         wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
         break;

      case eSS_LoadPodWait:
         // Wait for our list of pods to dock.
         // If they are done, then tell the player.
         // Formate to the player, remove the waypoint.
         // If we are told to halt, go to load pod stop.
         if (tPodUtil.LoadDone(cargo_set)) {
            iConversation.OneLiner(ship, "", "epo_cargo_load_done");
            iAI.PurgeOrders(ship);
            Task.Sleep(Task.Current(), 0.1);
            Sim.Destroy(waypoint);
            wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
         }else if (neworder == ePO_Halt) {
            iAI.PurgeOrders(ship);
            Task.Sleep(Task.Current(), 0.1);
            Sim.Destroy(waypoint);
            wingman_state = change_state(ship, wingman_state, eSS_LoadPodStop, debug_on);
         }
         break;

      case eSS_LoadPodStart:
         // Drop a waypoint and formate on it.
         // Look for pods and grab up as many as we can.

         next_state = eSS_Idle;
   
         if (!Object.PropertyExists(ship, "md_epic_shipinit")) { // No loading pods when on the spewer!

            if (!tMegaTrucking.IsMegafreighter(ship)) { // Megafreighters use their own method

               if (!Set.IsEmpty(tPodUtil.DockPorts(ship))){
                  cargo_set = Set.FromList(tPodUtil.TaggedPodList(ship, Global.Float("gt_distance_wakeup")));

                  // Reserve the pods we intend to load
                  cargo_set = tPodUtil.ClaimPods(ship, cargo_set);

                  if (!Set.IsEmpty(cargo_set)) {

                     waypoint = iSim.Cast(Sim.Create("ini:/sims/nav/waypoint","load point"));
                     Sim.PlaceAt(waypoint, ship);
                     Task.Sleep(Task.Current(), 0.1);
                     Sim.CopyOrientation(waypoint, ship);
                     iAI.PurgeOrders(ship);
                     iAI.GiveFormateOrder( ship, waypoint, 0.0, 0.0, 0.0 );

                     next_state = eSS_LoadPodWait;

                     iConversation.OneLiner(ship, "", "epo_load_cargo_pods_ack");
                  }else{
                     iConversation.OneLiner(ship, "", "epo_refuse_no_pods");
                  }
               }else {
                  iConversation.OneLiner(ship, "", "epo_refuse_no_empty_ports");
               }
            }
         }

         wingman_state = change_state(ship, wingman_state, next_state, debug_on);

         break;

      case eSS_LoadPodOne:
         // Drop a waypoint and formate on it.
         // Grab the target pod

         next_state = eSS_Idle;
   
         if (!Object.PropertyExists(ship, "md_epic_shipinit")) { // No loading pods when on the spewer!

            if (!tMegaTrucking.IsMegafreighter(ship)) { // Megafreighters use their own method

               if (!Set.IsEmpty(tPodUtil.DockPorts(ship))){

                  Set.Difference(cargo_set, cargo_set);

                  target = current_target(ship);

                  debug {
                     Debug.PrintHandle(target);
                     Debug.PrintString(" target pod\n");
                  }

                  if (T_CargoPod == iSim.Type(target)) {
                     Set.Add(cargo_set, target);
                  }

                  // Reserve the pods we intend to load
                  cargo_set = tPodUtil.ClaimPods(ship, cargo_set);

                  if (!Set.IsEmpty(cargo_set)) {

                     waypoint = iSim.Cast(Sim.Create("ini:/sims/nav/waypoint","load point"));
                     Sim.PlaceAt(waypoint, ship);
                     Task.Sleep(Task.Current(), 0.1);
                     Sim.CopyOrientation(waypoint, ship);
                     iAI.PurgeOrders(ship);
                     iAI.GiveFormateOrder( ship, waypoint, 0.0, 0.0, 0.0 );

                     next_state = eSS_LoadPodWait;

                     iConversation.OneLiner(ship, "", "epo_load_cargo_pod_ack");
                  }else{
                     iConversation.OneLiner(ship, "", "epo_refuse_no_pods");
                  }
               }else {
                  iConversation.OneLiner(ship, "", "epo_refuse_no_empty_ports");
               }
            }
         }

         wingman_state = change_state(ship, wingman_state, next_state, debug_on);

         break;

      case eSS_LoadPodStop:
         iConversation.OneLiner(ship, "", "epo_load_cargo_stopping_ack");

         // Halt any remaining pods.
         tPodUtil.FreePods(cargo_set);

         accept_order(ship, debug_on);
         next_state = new_order_state(neworder);
         wingman_state = change_state(ship, wingman_state, next_state, debug_on);

         break;

      case eSS_UnloadPodStart:
         if(!Object.PropertyExists(ship, "md_epic_shipinit"))	// No ditching on the spewer!
         {
            if(!tMegaTrucking.IsMegafreighter(ship))
            {

               cargo_list = List.FromSet(Sim.Children(ship));
               total = List.ItemCount(cargo_list);

               for (i=0;i<total;++i) {
                  pod = iShip.Cast(List.GetNth(cargo_list,i));
                  if (T_CargoPod == iSim.Type(pod)) {
                     iSim.SetDockingLock(ship, pod, false);
                     iShip.UndockSelf(pod);
                  }
               }	// end for(j...)
            } // end if(!tMegaTrucking...)
            else{
               tMegaTrucking.DitchPods(ship);
            }

            iConversation.OneLiner(ship, "", "epo_cargo_unloading_done");
         } else { // end if(!Object...)
            // We had to skip this ship because it is loading/unloading pods
            // so warn the player when this is all done.
            iConversation.OneLiner(ship, "", "epo_refuse_ship_docked");
         }

         wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);

         break;

      case eSS_FuelShipStart:
         // If the target is a ship that is low on fuel
         // Do a move order to the ship, and go to fuel ship wait.
         target = current_target(ship);
         next_state = eSS_Idle;

         if (TM_Ship & iSim.Type(target)) {
            if (tsShip.Fuel(iShip.Cast(target)) < tsShip.FuelMax(iShip.Cast(target))) {

               iConversation.OneLiner(ship, "", "epo_refuel_target_ack");

               iAI.PurgeOrders(ship);

               // Move up under the target ship.
               iAI.GiveFormateOrder(ship, 
                                    target,
                                    0,
                                    -1km,
                                    0);
               next_state = eSS_FuelShipWait;
            } else {
               iConversation.OneLiner(ship, "", String.Join("epo_refueling_finished+",Sim.Name(target)));
            }
         }
         wingman_state = change_state(ship, wingman_state, next_state, debug_on);
         break;

      case eSS_FuelShipWait:
      case eSS_FuelFleetWait:
         target_ship = iShip.Cast(current_target(ship));
         if (2km > Sim.DistanceBetween(ship, target_ship)) {
            filled = tanker_fill_ship(ship, target_ship);

            if (true == filled) {
               iConversation.OneLiner(ship, "", String.Join("epo_refueling_finished+",Sim.Name(target_ship)));
            }else {
               iConversation.OneLiner(ship, "", "epo_tanker_empty");
            }

            if ((wingman_state == eSS_FuelFleetWait) && (true == filled)) {
               // if we have any fuel, go back and fill another ship.
               wingman_state = change_state(ship, wingman_state, eSS_FuelFleetStart, debug_on);
            }else {
               wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
            }
         }
         break;

      case eSS_FuelFleetStart:
         // Pick the nearest player ship that is low on fuel.
         // Do a move order to the ship. go to fuel ship wait.
         // Refuels all player ships in Global.Float("gt_distance_wakeup").
         target_list = List.FromSet(iSim.SimsInRadiusFromSet(player_fleet(),
                                                             player, Global.Float("gt_distance_wakeup"), TM_Ship));

         List.AddHead(target_list, player);
         List.RemoveAll(fuel_list);

         // Get a list of non-tankers that need fuel.
         total = List.ItemCount(target_list);
         for (i=0;i<total;++i) {
            target_ship = iShip.Cast(List.GetNth(target_list, i));

            if (!tsShip.IsTanker(target_ship)){
               if (tsShip.Fuel(target_ship) < (tsShip.FuelMax(target_ship) - 1)) {
                  List.AddTail(fuel_list, target_ship);
               }
            }
         }

         if (List.ItemCount(fuel_list)) {
            iConversation.OneLiner(ship, "", "epo_fuel_fleet_ack");
            target_ship = iShip.Cast(List.Head(fuel_list));

            set_current_target(ship, target_ship);

            iAI.PurgeOrders(ship);

            // Move up under the target ship.
            iAI.GiveFormateOrder(ship, 
                                 target_ship,
                                 0,
                                 -1km,
                                 0);

            wingman_state = change_state(ship, wingman_state, eSS_FuelFleetWait, debug_on);
         }else {

            // Done. Tell the player.
            iConversation.OneLiner(ship, "", "epo_fleet_fueling_complete");
            wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
         }

         break;


      case eSS_FuelDrainStart:
         // Make sure the target is a pod we can drain, then move to the
         // target. Complete check has already been done.
         target = current_target(ship);
         next_state = eSS_Idle;

         if (T_CargoPod == iSim.Type(target)) {
               iConversation.OneLiner(ship, "", "epo_drain_fuel_ack");

               iAI.PurgeOrders(ship);

               // Move up under the target ship.
               iAI.GiveFormateOrder(ship, 
                                    target,
                                    0,
                                    -1km,
                                    0);
               next_state = eSS_FuelDrainWait;
         }
         wingman_state = change_state(ship, wingman_state, next_state, debug_on);
         break;

      case eSS_FuelDrainWait:
         target_ship = iShip.Cast(current_target(ship));
         if (2km > Sim.DistanceBetween(ship, target_ship)) {
            tanker_empty_ship(ship, target_ship);

            iConversation.OneLiner(ship, "", "epo_fuel_drain_complete");
            wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
         }
         break;
         // Docks to nearest asteroid and begins science survey.
      case eSS_ProspectStart:
         target = current_target(ship);

         if (none != target) {

            iAI.PurgeOrders(ship);
            iAI.GiveDockOrder(ship, target);
            iConversation.OneLiner(ship, "", "epo_prospector_ack");
            wingman_state = change_state(ship, wingman_state, eSS_ProspectWait, debug_on);

         }else {
            iConversation.OneLiner(ship, "", "epo_prospector_docking_cancelled");
            wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);

         }
         break;

      case eSS_ProspectWait:
         // Wait in this state for an undock order.
         if (iSim.IsDockedTo(ship, target)) {

            iConversation.Begin();
            // epo_prospector_attaching, "We are attached to the surface."
            iConversation.Say(ship,"", "epo_prospector_attaching");
            // epo_prospector_survey_delay, "The survey will take a few days."
            iConversation.Say(ship,"", "epo_prospector_survey_delay");
            // epo_prospector_send_email, "We will notify you by email when we are done."
            iConversation.Say(ship,"", "epo_prospector_send_email");
            iConversation.End();

            wingman_state = change_state(ship, wingman_state, eSS_Prospect, debug_on);
         }else if (neworder == ePO_Undock) {
            accept_order(ship, debug_on);
            next_state = new_order_state(neworder);
            wingman_state = change_state(ship, wingman_state, next_state, debug_on);
         }else if (OT_None == iAI.CurrentOrderType(ship)) {
            if (none == tsShip.DockParent(ship)) {
               // The order ended without docking the ship. Return to idle.
               iConversation.OneLiner(ship, "", "epo_prospector_docking_cancelled");
               wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
            }
         }
         break;

      case eSS_Prospect:
         if (neworder == ePO_Undock) {
            iConversation.OneLiner(ship, "", "epo_prospector_undocking");
            accept_order(ship, debug_on);
            next_state = new_order_state(neworder);
            wingman_state = change_state(ship, wingman_state, next_state, debug_on);
         }
         break;

         // Docks to nearest asteroid and begins mining.
      case eSS_MineStart:
         target = new_target(ship);

         if (none != target) {

            iAI.PurgeOrders(ship);
            iAI.GiveDockOrder(ship, target);
            iConversation.OneLiner(ship, "", "epo_miner_docking_ack");
            wingman_state = change_state(ship, wingman_state, eSS_MineWait, debug_on);

         }else {
            iConversation.OneLiner(ship, "", "epo_mining_dock_cancelled");
            wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);

         }         
         break;

      case eSS_MineWait:
         if (iSim.IsDockedTo(ship, target)) {
            iConversation.OneLiner(ship, "","epo_mining_rig_docked");
            wingman_state = change_state(ship, wingman_state, eSS_Mine, debug_on);
         }else if (neworder == ePO_Undock) {
            iConversation.OneLiner(ship, "", "epo_mining_dock_cancelled");
            accept_order(ship, debug_on);
            next_state = new_order_state(neworder);
            wingman_state = change_state(ship, wingman_state, next_state, debug_on);
         }else if (OT_None == iAI.CurrentOrderType(ship)) {

            if (none == tsShip.DockParent(ship)) {
               // The order ended without docking the ship. We could have been attacked,
               // or some other change. Return to idle, that will let up pick up orders.
               iConversation.OneLiner(ship, "", "epo_mining_dock_cancelled");
               wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
            }
         }
         break;

      case eSS_Mine:
         if (neworder == ePO_Undock) {
            iConversation.OneLiner(ship, "", "epo_mining_rig_undocking");
            accept_order(ship, debug_on);
            next_state = new_order_state(neworder);
            wingman_state = change_state(ship, wingman_state, next_state, debug_on);
         }
         break;

      case eSS_LongScanStart:
         iConversation.OneLiner(ship, "", "epo_scan_order_ack");

         waypoint = iSim.Cast(Sim.Create("ini:/sims/nav/waypoint","scan_point"));
         Sim.PlaceAt(waypoint, ship);
         Task.Sleep(Task.Current(), 0.1);
         iAI.PurgeOrders(ship);
         iAI.GiveFormateOrder(ship, 
                              waypoint,
                              0,
                              0,
                              0);

         wingman_state = change_state(ship, wingman_state, eSS_LongScanDeploy, debug_on);
         break;

      case eSS_LongScanDeploy:
         // Wait here until the ship has stopped moving and it at the waypoint.
         if ((Sim.DistanceBetween(ship, waypoint) < 1km) && (Sim.Speed(ship) < 10)) {
            iConversation.OneLiner(ship, "", "epo_scan_started");
            wingman_state = change_state(ship, wingman_state, eSS_LongScanWait, debug_on);
            scan_timer = 10;
         }else if (neworder != ePO_None) {
            // Accept any new order.
            iAI.PurgeOrders(ship);
            Task.Sleep(Task.Current(), 0.1);
            Sim.Destroy(waypoint);
            wingman_state = change_state(ship, wingman_state, eSS_LongScanStop, debug_on);
         }

         break;

      case eSS_LongScanWait:
         // Wait here for however long a long scan takes. A few seconds.
         // Break if we get another order.
         --scan_timer;

         if (scan_timer < 0){
            // Do the scan and report results. Pack up the sensors.

            // Find all stations within 500,000km and make them visible.
            stations = iSim.SimsInRadius( ship,
                                       Object.IntProperty(ship, "scan_range"),
                                       T_Station);
            new_station = false;

            while (!Set.IsEmpty(stations)) {
               station = iHabitat.Cast(Set.FirstElement(stations));
               Set.Remove(stations, station);

               // Reveal the station if it exists, or has ever existed.
               if (tStation.Status(station) != ESS_NeverBuilt) {

                  // We used to not reveal pirate stations. Except there is no 
                  // way to find pirate stations in the outback areas and the player
                  // needs to be to hunt those hunting him, so now we reveal all stations.
                  if (!iMapEntity.IsVisibleOnMap(station)) {
                     // If the station is invisible to player, let them see it,
                     // save a note, to tell the player when done.
                     tStation.SetMapVisibility(station, true);
                     new_station = true;
                  }
               }

            }//while nearby stations

            if (new_station) {
               iConversation.OneLiner(ship, "", "epo_scan_sky_success");
            }else {
               iConversation.OneLiner(ship, "", "epo_scan_sky_failed");
            }

            wingman_state = change_state(ship, wingman_state, eSS_LongScanStop, debug_on);
         }else if (neworder != ePO_None) {
            // Accept any new order.
            wingman_state = change_state(ship, wingman_state, eSS_LongScanStop, debug_on);
         }
         break;

      case eSS_LongScanStop:
         iConversation.OneLiner(ship, "", "epo_scan_packing");

         iAI.PurgeOrders(ship);
         Task.Sleep(Task.Current(), 0.1);
         Sim.Destroy(waypoint);

         // Pack up any sensors. For now, just go idle and let that sort out the 
         // command.
         wingman_state = change_state(ship, wingman_state, eSS_Idle, debug_on);
         break;

      default:
         // Should not be here, change state to eSS_None.
         wingman_state = change_state(ship, wingman_state, eSS_None, debug_on);
         break;
      }
   }
}
//[cf]


// Converts player orders into starting states.
//[of]:eShipState new_order_state(ePlayerOrder neworder)
eShipState new_order_state(ePlayerOrder neworder)
{

   switch (neworder) {
   case ePO_Halt:
      return eSS_HaltStart;
      break;
   case ePO_Attack:
      return eSS_AttackStart;
      break;
   case ePO_DefendMe:
      return eSS_EscortStart;
      break;
   case ePO_Escort:
      return eSS_EscortStart;
      break;
   case ePO_Formate:
      return eSS_FormateStart;
      break;
   case ePO_Dock:
      return eSS_DockStart;
      break;
   case ePO_Undock:
      return eSS_Undock;
      break;
   case ePO_CollectAllPods:
      return eSS_LoadPodStart;
      break;
   case ePO_CollectPod:
      return eSS_LoadPodOne;
      break;
   case ePO_UndockPods:
      return eSS_UnloadPodStart;
      break;
   case ePO_FuelShip:
      return eSS_FuelShipStart;
      break;
   case ePO_FuelFleet:
      return eSS_FuelFleetStart;
      break;
   case ePO_DrainFuel:
      return eSS_FuelDrainStart;
      break;
   case ePO_Prospect:
      return eSS_ProspectStart;
      break;
   case ePO_ScanSky:
      return eSS_LongScanStart;
      break;
   case ePO_Mine:
      return eSS_MineStart;
      break;
   default:
      break;
   }

   // Missed one. Restart the ship. 
   return eSS_None;
}
//[cf]


//[of]:new_order

ePlayerOrder new_order(hship ship)
{
   return int2order(Object.IntProperty(ship,"gtNewOrder"));
}

set_new_order(hship ship, ePlayerOrder order)
{
   Object.AddIntProperty(ship,"gtNewOrder", order);
}
//[cf]


//[of]:current_order

ePlayerOrder current_order(hship ship)
{
   return int2order(Object.IntProperty(ship,"gtCurrentOrder"));
}

set_current_order(hship ship, ePlayerOrder order)
{
   Object.AddIntProperty(ship,"gtCurrentOrder", order);
}
//[cf]


//[of]:current_target

hisim current_target(hship ship)
{
   return iSim.Cast(Object.HandleProperty(ship,"gtCurrentTarget"));
}

set_current_target(hship ship, hisim target)
{
   Object.AddHandleProperty(ship,"gtCurrentTarget", target);
}
//[cf]


//[of]:new_target

hisim new_target(hship ship)
{
   return iSim.Cast(Object.HandleProperty(ship,"gtNewTarget"));
}

set_new_target(hship ship, hisim target)
{
   Object.AddHandleProperty(ship,"gtNewTarget", target);
}
//[cf]


//[of]:ship_state

set_ship_state(hship ship, eShipState status)
{
   Object.AddIntProperty(ship,"gtShipState", status);
}


eShipState ship_state(hship ship)
{
   return int2state(Object.IntProperty(ship,"gtShipState"));
}
//[cf]


//[of]:accept_order(hship ship, bool debug_on)
accept_order(hship ship, bool debug_on)
{
   atomic {
      // Accept the new order as the ships current order.

         set_current_target(ship, new_target(ship));
         set_current_order(ship, new_order(ship));

         // Clear the new order flag.
         set_new_order(ship, ePO_None);
   }
}
//[cf]


//[of]:eShipState change_state(hship ship, eShipState state, eShipState new_state, bool debug_on)
eShipState change_state(hship ship, eShipState state, eShipState new_state, bool debug_on)
{
   debug {
      if (debug_on) {
         Debug.PrintString(Text.Field(Sim.Name(ship),FT_Text));
         Debug.PrintString(" change ");
         Debug.PrintString(state2string(state));
         Debug.PrintString("->");
         Debug.PrintString(state2string(new_state));
         Debug.PrintString("\n");

      }
   }

   set_ship_state(ship, new_state);

   return new_state;
}
//[cf]




// Does the fuel move between tanker and target ship.
// Returns true if the tanker still has more fuel.
//[of]:bool tanker_fill_ship(hship tanker, hship target)
bool tanker_fill_ship(hship tanker, hship target)
{
   int timer;
   bool full_tanker = true;
   float min_fuel, max_fuel;
   float fuel_left, fuel_needed, fuel_moved, fuel_target, fuel_tanker;
   string response;

   min_fuel = 2 * tsShip.FuelPerJump(tanker);
   max_fuel = tsShip.FuelMax(target);

   atomic {

      // Calculate max that we can fit in target.
      // This is the transfer amount.
      fuel_target = tsShip.Fuel(target);
      fuel_needed = max_fuel - fuel_target;

      // Clip the transfer amount to the minimum the tanker
      // has remaining.
      fuel_tanker = tsShip.Fuel(tanker);
      fuel_left = fuel_tanker - min_fuel;

      if (fuel_left < fuel_needed) {
         fuel_moved = fuel_left;
         full_tanker = false;
      } else {
         fuel_moved = fuel_needed;
      }

      tsShip.SetFuel(tanker, fuel_tanker - fuel_moved);
      tsShip.SetFuel(target, fuel_target + fuel_moved);
   }



   return full_tanker;
}
//[cf]



// Tanker pulls fuel from the target ship. If the target is
// rendered empty, then return true. If a little fuel
// remains, return false (to let player know they can 
// fill more tankers.
//[of]:bool tanker_empty_ship(hship tanker, hship target)
bool tanker_empty_ship(hship tanker, hship target)
{
   bool finished = false;
   float max_fuel, fuel_left, fuel_needed, fuel_used;

   max_fuel = tsShip.FuelMax(tanker);

   atomic {
      // Calc the amount of fuel to transfer in this time
      fuel_used = tsShip.Fuel(tanker);
      fuel_needed = max_fuel - fuel_used;

      // Calculate fuel left in pod after we pump some out.
      if (T_CargoPod & iSim.Type(target)) {
         fuel_left = 500;
      }else {
         fuel_left = tsShip.Fuel(target);
      }

      if (fuel_left < fuel_needed) {
         fuel_needed = fuel_left;
         fuel_left = 0.0;
         finished = true;
      } else {
         fuel_left = fuel_left - fuel_needed;
      }

      // Now that we have max transfer amount, move fuel.
      fuel_used = fuel_used + fuel_needed;
      tsShip.SetFuel(tanker, fuel_used);
      tsShip.SetFuel(target, fuel_left);
   }

   if (T_CargoPod & iSim.Type(target)) {
      if (fuel_left < 250.0) {
         // Once the pod is half empty, mark it empty.
         Object.SetIntProperty(target, "cargo", CT_Invalid);
         iUtilities.RenameSim(target,"Cargo_Empty");
      }
   }

   return finished;
}
//[cf]



//[of]:string state2string(eShipState state)
string state2string(eShipState state)
{
   switch (state) {
   case eSS_None:   
      return "eSS_None";
      break;
   case eSS_NoPlayer:
      return "eSS_NoPlayer";
      break;

   case eSS_Idle:
      return "eSS_Idle";
      break;
   case eSS_NoFuel:
      return "eSS_NoFuel";
      break;

   case eSS_HaltStart:   
      return "eSS_HaltStart";
      break;
   case eSS_HaltWait:   
      return "eSS_HaltWait";
      break;

   case eSS_EscortStart:   
      return "eSS_EscortStart";
      break;
   case eSS_Escort:   
      return "eSS_Escort";
      break;

   case eSS_FormateStart:   
      return "eSS_FormateStart";
      break;
   case eSS_Formate:   
      return "eSS_Formate";
      break;

   case eSS_AttackStart:   
      return "eSS_AttackStart";
      break;
   case eSS_Attack:   
      return "eSS_Attack";
      break;
   case eSS_AttackNewTarget:   
      return "eSS_AttackNewTarget";
      break;

   case eSS_FleeStart:   
      return "eSS_FleeStart";
      break;
   case eSS_Flee:   
      return "eSS_Flee";
      break;

   case eSS_DockStart:   
      return "eSS_DockStart";
      break;
   case eSS_Dock:   
      return "eSS_Dock";
      break;

   case eSS_Undock:   
      return "eSS_Undock";
      break;

   case eSS_CargoDockStart:   
      return "eSS_CargoDockStart";
      break;
   case eSS_CargoDock:   
      return "eSS_CargoDock";
      break;

   case eSS_LoadPodStart:   
      return "eSS_LoadPodStart";
      break;
   case eSS_LoadPodWait:   
      return "eSS_LoadPodWait";
      break;
   case eSS_LoadPodStop:   
      return "eSS_LoadPodStop";
      break;
   case eSS_LoadPodOne:   
      return "eSS_LoadPodOne";
      break;

   case eSS_UnloadPodStart:   
      return "eSS_UnloadPodStart";
      break;
   case eSS_UnloadPodWait:   
      return "eSS_UnloadPodWait";
      break;

   case eSS_FuelShipStart:   
      return "eSS_FuelShipStart";
      break;
   case eSS_FuelShipWait:   
      return "eSS_FuelShipWait";
      break;
   case eSS_FuelFleetWait:   
      return "eSS_FuelFleetWait";
      break;
   case eSS_FuelFleetStart:   
      return "eSS_FuelFleetStart";
      break;
   case eSS_FuelHalt:   
      return "eSS_FuelHalt";
      break;

   case eSS_FuelDrainStart:   
      return "eSS_FuelDrainStart";
      break;
   case eSS_FuelDrainWait:   
      return "eSS_FuelDrainWait";
      break;

   case eSS_ProspectStart:   
      return "eSS_ProspectStart";
      break;
   case eSS_ProspectWait:   
      return "eSS_ProspectWait";
      break;
   case eSS_Prospect:   
      return "eSS_Prospect";
      break;

   case eSS_MineStart:   
      return "eSS_MineStart";
      break;
   case eSS_MineWait:   
      return "eSS_MineWait";
      break;
   case eSS_Mine:   
      return "eSS_Mine";
      break;

   case eSS_LongScanStart:
      return "eSS_LongScanStart";
      break;
   case eSS_LongScanStop:   
      return "eSS_LongScanStop";
      break;
   case eSS_LongScanDeploy:   
      return "eSS_LongScanDeploy";
      break;
   case eSS_LongScanWait:   
      return "eSS_LongScanWait";
      break;

   default:
      break;
   }

   return "eSS_Invalid";

}
//[cf]


//[of]:ePlayerOrder int2order(int order)
ePlayerOrder int2order(int order)
{
   return order;
}
//[cf]


//[of]:eShipState int2state (int state)
eShipState int2state (int state)
{
   return state;
}
//[cf]


// tsPlayerFleet.PlayerFleet()
// We access this global directly because otherwise we lock up the linker.
//[of]:set player_fleet()
set player_fleet()
{
   return Global.Set("g_epic_fleet_player_list");
}
//[cf]


// Don't allow attacks on planets, nebula or other non-ship or station type items.
//[of]:bool is_valid_target(hisim target)
bool is_valid_target(hisim target)
{
   if (iSim.Type(target) & (TM_Ship | T_Asteroid | T_CargoPod | T_Gunstar | T_Station | T_BioBomber)) {
      return true;
   }

   return false;
}
//[cf]


// Don't allow approch orders to stars or planets or missiles or other odd items.
//[of]:bool is_valid_destination(hisim target)
bool is_valid_destination(hisim target)
{
   if (iSim.Type(target) & (TM_Ship | T_Waypoint | T_LagrangePoint | T_Asteroid | T_CargoPod
                            | T_Gunstar | T_Station | T_BioBomber)) {
      return true;
   }

   return false;
}
//[cf]


//[of]:bool station_known(int station_type)
bool station_known(int station_type)
{

   switch (station_type) {
   case ept_PirateBase :
   case ept_PirateCove :
   case ept_PirateOutpost:
   case ept_GangsterHideout:
      return false;
      break;
   default:
      break;
   }

   return true;
} 
//[cf]


//[of]:bool is_mine(hisim station)
bool is_mine(hisim station)
{
   int station_type;

   if (T_Station != iSim.Type(station)) {
      return false;
   }

   if (ESC_Mine == tStation.Category(iHabitat.Cast(station))) {
      return true;
   }

   return false;
}
//[cf]




/*    
THIS MOD IS NOT MADE, DISTRIBUTED, OR SUPPORTED BY INFOGRAMES
OR PARTICLE SYSTEMS LTD. 

ELEMENTS TM & (C) INFOGRAMES AND PARTICLE SYSTEMS LTD.
*/
