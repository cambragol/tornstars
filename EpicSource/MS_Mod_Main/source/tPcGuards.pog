//*******************************************************************************************/
//
// tPcGuards
//
// This pog object implements station guards. They patrol around stations and 
// attack dislike and hostile ships. They respond to local distress calls and move
// to protect the station. They create ships based on the number of fleets the 
// station has, and thier deaths subtract from that number.
//
// March 2005, Jon Freise
// March 2006, jf major rewrite supporting station guards, and improved AI behavior.
//******************************************************************************************/

package tPcGuards;

uses    Sim,
        iShip,
        iSim,
        Debug,
        Global,
        GUI,
        iGUI,
        iHUD,
        INIFile,
        Input,
        List,
        Object,
        String,
        Task,
        Text,
        Math,
        iShipCreation,
        iComms,
        iConversation,
        iMapEntity,
        iLagrangePoint,
        iAI,
        iPilotSetup,
        iShipCreation,
        iEscort,
        ABB_Common,

        tPodUtil,
        tEpicComms,
        tsFaction,
        tEpicMoney,
        tShipName,
        tLCenter,
        tLFleet,
        tsShipCreationEnum,
tsShipCreation,
        tsPilotSetup,
        tEJump,
        tDistance,
        tUnderOp,
        uString,
        tEpicEventEnum,
        tsEvent,
        tsDistress,
        tPcOwner,
        tsShip;


provides PogCreate,
         PogStart;


enum eCSScriptState
{
   eCS_Init,
   eCS_ToDestination,
   eCS_WaitApproach,
   eCS_CheckNearby,
   eCS_Attacked,
   eCS_Fight,
   eCS_Distress,
   eCS_Dead,
   eCS_Cull
};

prototype setup_guards(hisim marker);


prototype task guard_controller(hmapentity location, 
                                hgroup patrol_group);


prototype hmapentity nearby_location(hisim center);



prototype hship create_leader (hmapentity location, 
                               hisim operation, 
                               hgroup cull_group,
                               string ship_type);


prototype create_escorts(hisim operation, 
                          int fleets, 
                          hship leader, 
                          hgroup cull_group,
                          string ship_type);


prototype set filter_feeling(set ships, 
                             hfaction faction, 
                             float feeling);


prototype bool check_for_attacks(hgroup patrol_group);

prototype bool check_for_distress(hgroup patrol_group);


prototype eCSScriptState change_state(eCSScriptState state, 
                                      eCSScriptState new_state, 
                                      bool debug_on);


prototype string state2string(eCSScriptState state);



/*
   Test code just looks up a sim type from the properties section of 
   the class instance INI file. It creates that Sim and passes it 
   back.

*/


hsim PogCreate(string template_name, string object_name)
{

   hinifile object_file;
   string name;
   string item_template, pog_class, start_function;
   hsim item;


   debug Debug.PrintString("tPcGuards.PogCreate\n");

   object_file = INIFile.Create(template_name);

   if (none == object_file) {
      debug {
         Debug.PrintString("tPcGuards.PogCreate, failed to find object file\n");
      }

      return item;
   }

   // Pull needed items out of template file. Create the object.
   // Attach them

   pog_class = INIFile.String(object_file, "PogClass","name","none");


   ///********************
   // This block of code is class dependent. The rest must be done to adhere
   // to the pog otbject calling conventions.

//   item_template = INIFile.String(object_file, "Properties","template","none");

   INIFile.Destroy(object_file);

//   name = tShipName.ShipName( "underworld", Math.RandomInt(0, 222));

//   item = Sim.Create(item_template, name);

   item = Sim.Create("ini:/sims/nav/waypoint","guard_mark");

   if (none == item) {
      debug {
         Debug.PrintString("tPcGuards.PogCreate, error bad object template\n");
      }
      return item;
   }

   Sim.SetCullable(item, false);

   ///********************


   // All 
   Object.AddStringProperty(item, "gt_pog_object_class", pog_class);
   Object.AddStringProperty(item, "gt_pog_object_template", template_name);

      
   return item;
}


/*
This function is called after the ship has been placed. 

*/
task PogStart(hsim pog_object)
{

   debug Debug.PrintString("tPcGuards: starting\n");

   ///***************************************
   // This part of the start code is object dependent. The prior pieces must
   // be done to adhere to the pog class calling convention.

   setup_guards(iSim.Cast(pog_object));

   ///***************************************
}

/*
; 


[PogClass]
name=tPcGuards

[Properties]

template=ini:/sims/ships/navy/patcom

*/



// Read the ini file, setup the object. 
setup_guards(hisim marker)
{
   hinifile control_file;
   string template_file_name;
   hmapentity location;
   hfaction guard_faction;
   hfaction player_faction = tsFaction.PlayerFaction();
   hisim owner;

   string leader_type, escort_type;
   int i, total;
   float threat;
   int fleets;

   hship patrol_ship;
   hgroup patrol_group = Group.Create();

   if (none == marker) {
      debug Debug.PrintString("ERROR tPcGuards.setup_toll_marker invalid sim\n");
      return;
   }

   template_file_name = Object.StringProperty(marker, "gt_pog_object_template");
   control_file = INIFile.Create(template_file_name);

   if (none == control_file) {
      debug Debug.PrintString("ERROR tPcGuards error invalid template_file\n");
      debug Debug.PrintString(template_file_name);
      debug Debug.PrintString("\n");
      return;
   }

   leader_type = INIFile.String(control_file,"Properties","leader_ship_type","EST_CombatLight");

   escort_type = INIFile.String(control_file,"Properties","escort_ship_type","EST_CombatFighter");

   INIFile.Destroy(control_file);

   location = nearby_location(marker);

   if (none == location) {
      debug Debug.PrintString("ERROR tPcGuards error no nearby location\n");
      return;
   }

   // Find the operation owner of the toll.
   owner = iSim.Cast(tPcOwner.Owner(marker));
   guard_faction = iSim.Faction(iSim.Cast(owner));

   if (none == owner) {
      debug Debug.PrintString("ERROR tPcGuards error no owning station or operation\n");
      return;
   }

   // Block the operation from spawning guards twice. Happens when player chases
   // an operation from one location to another.
   if (tUnderOp.IsOperation(owner)) {
      if (tUnderOp.IsCreated(owner)){
         debug Debug.PrintString("tPcGuards operation already physical.\n");
         return;
      }
   }

   // How many ships are supported by this operation/station?
   fleets = tLFleet.Fleets(owner);

   if (fleets < 40) {
      debug Debug.PrintString("tPcGuards no fleets remain, exiting.\n");
      return;
   }

   patrol_ship = create_leader (location, owner, patrol_group, leader_type);

   // Subtract off the fleets that are needed for the patrol ship.
   fleets = fleets - Object.FloatProperty(patrol_ship, "threat");

   // Create escorts with the remaining fleet value.
   create_escorts(owner, fleets, patrol_ship, patrol_group, escort_type);

   // Launch the toll controller task.
   Task.Detach(start guard_controller(location, patrol_group));

   // We can remove the guard mark now.
   Sim.Destroy(marker);
}



// The guard controller flys waypoints around the location.
// If the location is culled, the ships are set to allow culling.
// If a hostile ship is seen, the leader attacks.
task guard_controller(hmapentity location, hgroup patrol_group)
{
   set dislike_set;
   hship player;
   hfaction player_faction = tsFaction.PlayerFaction();
   hfaction guard_faction;
   hfaction sender_faction, target_faction;
   hship patrol_leader;
   hship target_ship;
   hisim sender, target;
   hisim marker;
   string speech_style;
   float delay_time = 3.0; // Allow some pause between state changes.
   int timer = 0;
   float spacing, radius, rotation, distance;
   float sender_feeling, target_feeling;
   int event_type;
   bool do_rescue;
   bool debug_on = Global.Bool("gt_tpcguards_debug");
   eCSScriptState state = eCS_Init;


   patrol_leader = iShip.Cast(Group.Leader(patrol_group));
   guard_faction = iSim.Faction(patrol_leader);

   tsEvent.InitReciever(patrol_group);
   tsEvent.SetListenType(patrol_group, eseDistress | eseSelfAttacked | eseStationAttack);

   speech_style = tsFaction.SpeechStyle(guard_faction);

   while (1) {

      // Handle the outside cases. The player changing systems.
      // The ships getting killed.
      // Culling needing to happen.
      if (tEJump.IsCapsuleJumping()) {
         state = change_state(state, eCS_Cull, debug_on);
      }else {

         player = iShip.FindPlayerShip();

         if (Sim.IsDead(patrol_leader)) {
            if (eCS_Cull != state) {
               state = change_state(state, eCS_Dead, debug_on);
            }
         }else if (Sim.DistanceBetween(iShip.Cast(Group.Leader(patrol_group)), player) > 
                   tDistance.CullingDistance()) {

            // Station guards cull fast to allow player to return quick.
            ++timer;
            if (timer > (6/delay_time)) {
               state = change_state(state, eCS_Cull, debug_on);
            }
         }else if (check_for_attacks(patrol_group)){
            timer = 0;
            state = change_state(state, eCS_Attacked, debug_on);
         }else {
            timer = 0;
         }
      }

      switch (state) {
      case eCS_Init:
         // Form up the patrol group, start them moving.

         spacing = iUtilities.GetLargestShipRadius( patrol_group);
         iEscort.Wedge( patrol_group, spacing, 50km, true );

         marker = iSim.Cast(Sim.Create("ini:/sims/nav/waypoint", "patrol mark"));

         rotation = Math.Random(0,360);

         distance = Sim.DistanceBetween(patrol_leader, location);

         state = change_state(state, eCS_ToDestination, debug_on);
         break;

      case eCS_ToDestination:
         // Send the leader orbiting the station.

         Sim.PlaceRelativeTo(marker, location, 
                             Math.Sin(rotation) * distance, 
                             0, 
                             Math.Cos(rotation)* distance);

         rotation = rotation + 120;
         if (rotation > 720) {
            rotation = 0;
         }else if (rotation > 360) {
            rotation = rotation - 360;
         }

         iAI.PurgeOrders(patrol_leader);
         iAI.GiveApproachOrder( patrol_leader, marker);

         state = change_state(state, eCS_WaitApproach, debug_on);

         break;

      case eCS_WaitApproach:

         // Wait here until the AI has halted, then pick new marker location.
         if (OT_None == iAI.CurrentOrderType(patrol_leader)) {
            state = change_state(state, eCS_CheckNearby, debug_on);
         }

         break;

      case eCS_CheckNearby:

         // Test nearby ships for hostile action.
         dislike_set = filter_feeling(iSim.ShipsInRadius(patrol_leader, 50km), guard_faction, -2.0);

         if (!Set.IsEmpty(dislike_set)) {

            iComms.Shout(patrol_leader,"", uString.CommsStringRandom("pcgs_guard_hostile_spotted",speech_style, 5));

            // Pick the first one, attack.
            target_ship = iShip.Cast(Set.FirstElement(dislike_set));
            iAI.PurgeOrders(patrol_leader);
            iAI.GiveAttackOrder(patrol_leader, target_ship);

            state = change_state(state, eCS_Fight, debug_on);

         }else if (check_for_attacks(patrol_group)){

            state = change_state(state, eCS_Attacked, debug_on);

         }else if (check_for_distress(patrol_group)){

            state = change_state(state, eCS_Distress, debug_on);

         }else {

            iComms.Shout(patrol_leader,"",uString.CommsStringRandom("pcgs_guard_sweep_finished",speech_style,5));
            state = change_state(state, eCS_ToDestination, debug_on);

         }

         break;

      case eCS_Attacked:
         // Some we are guarding has been attacked.
         sender = tsEvent.GetSender(patrol_group);
         target = tsEvent.GetTarget(patrol_group);
         event_type = tsEvent.GetEventType(patrol_group);

         tsEvent.RemoveEvent(patrol_group);

         sender_faction = iSim.Faction(sender);
         target_faction = iSim.Faction(target);

         // Make sure it was not friendly fire, then attack the attacker.
         if (guard_faction != target_faction) {
            
            // Answer the stations distress call.
            if (event_type == eseStationAttack ) {
               iComms.Shout(patrol_leader,"",uString.CommsStringRandom("pcgs_answering_distress_call",speech_style, 5));
            }else {
               iComms.Shout(patrol_leader,"", uString.CommsStringRandom("pcgs_guard_hostile_spotted",speech_style, 5));
            }

            iAI.PurgeOrders(patrol_leader);

            // We order the patrol group to attack the targets group.
            if (none != Sim.Group(target)) {
               iAI.GiveAttackOrder(Sim.Group(patrol_leader), Sim.Group(target));
            }else {
               iAI.GiveAttackOrder(Sim.Group(patrol_leader), target);
            }

            //iAI.GiveAttackOrder(patrol_leader, target);
            state = change_state(state, eCS_Fight, debug_on);


            // Issue a distress call to all nearby groups. This opens the 
            // Event up to wider audience.
            tsDistress.Send(espDistress,
                            eseDistress,
                            patrol_leader,
                            target,
                            patrol_leader,
                            200km);

         }else {
            // Friendly fire, with the event cleared, check for 
            // hostiles again.
            state = change_state(state, eCS_CheckNearby, debug_on);
         }

         break;
      case eCS_Fight:
         // A battle has broken out. We wait here.
         if ( (Sim.DistanceBetween(patrol_leader, location) > 100km) 
             && (OT_Escort != iAI.CurrentOrderType(patrol_leader))) {
            // Station guards do not chase down targets. Instead,
            // if the patrol leader is chasing, give an escort order.
            // This will bring the patrol group back to the station.

            iAI.PurgeOrders(patrol_leader);
            radius = iAI.AvoidanceRadius( iSim.Cast(location), patrol_leader );
            iAI.GiveEscortOrder(patrol_leader, location, radius, 0, 0, 50km);
         }

         break;
      case eCS_Distress:
         // A distress call was signalled, here we choose if we respond, or if
         // we just ignore the event.

         // If we are Neutral or better with the defender, and
         // if we are equal or higher feeling with the defender,
         // we respond. Give attack order and go to fight state.
         // Shout we are responding.
         
         do_rescue = false;

         sender = tsEvent.GetSender(patrol_group);
         target = tsEvent.GetTarget(patrol_group);

         tsEvent.RemoveEvent(patrol_group);

         // We only do short range rescue missions.
         if (Sim.DistanceBetween(sender, patrol_leader) < 200km) {

            sender_faction = iSim.Faction(sender);
            target_faction = iSim.Faction(target);

            sender_feeling = iFaction.Feeling(guard_faction, sender_faction);
            target_feeling = iFaction.Feeling(guard_faction, sender_faction);

            if (sender_feeling > -0.2 ){
               if (sender_feeling >= target_feeling) {
                  do_rescue = true;
               }
            }// if we like these people.
         }// if close.

         if (do_rescue) {
            iComms.Shout(patrol_leader,"", uString.CommsStringRandom("pcgs_answering_distress_call",speech_style, 5));

            iAI.PurgeOrders(patrol_leader);

            // We order the patrol group to attack the targets group.
            if (none != Sim.Group(target)) {
               iAI.GiveAttackOrder(Sim.Group(patrol_leader), Sim.Group(target));
            }else {
               iAI.GiveAttackOrder(Sim.Group(patrol_leader), target);
            }

            state = change_state(state, eCS_Fight, debug_on);
         }else {
            // Not interested in helping, keep looking for trouble.
            state = change_state(state, eCS_CheckNearby, debug_on);
         }

         break;

      case eCS_Dead:
         // patrol leader is dead. Select another. No more
         // waypoint chasing, we let the escorts fight without
         // giving more orders.

         // If all the escorts are dead, we cull.
         Group.RemoveSim(patrol_group, patrol_leader);
         patrol_leader = iShip.Cast(Group.Leader(patrol_group));
         if (none == patrol_leader) {
            state = change_state(state, eCS_Cull, debug_on);
         }else {
            state = change_state(state, eCS_Fight, debug_on);
         }

         break;

      case eCS_Cull:
         // Player is far, or all the ships are dead. Set the last to allow
         // culling and exit task.
         iAI.PurgeOrders(patrol_group);
         ABB_Common.SetCullableGroup(patrol_group, true);
         Group.Destroy(patrol_group, false);
         debug atomic {
            Debug.PrintString("tPcGuards all ships culled, exit\n");
         }
         return;
         break;

      default:
         state = change_state(state, eCS_Init, debug_on);

         break;
      }


      Task.Sleep(Task.Current(), delay_time);
   }
}


// This function checks if the patrol
// group was attacked, or if the station
// we are guarding was attacked.

bool check_for_attacks(hgroup patrol_group)
{
   hship new_target = none;
   int event_type;

   if (tsEvent.IsNewEvent(patrol_group)) {

      event_type = tsEvent.GetEventType(patrol_group);
      switch (event_type) {
      case eseSelfAttacked:
      case eseStationAttack:
         // One of our guys was attacked.
         // Get the attacking ship.
         return true;
         break;
      default:
         // We ignore other events to let other handlers take them.
         break;
      }
   }

   return false;
}

bool check_for_distress(hgroup patrol_group)
{
   hship attacker, target;
   hship new_target = none;
   int event_type;

   if (tsEvent.IsNewEvent(patrol_group)) {
      event_type = tsEvent.GetEventType(patrol_group);

      if (eseDistress == event_type) {
         // We don't clear the event, so that the 
         // handler code can read the attacker and location
         // information.

         return true;
      }
   }

   return false;
}

// Finds the closest location or station.
hmapentity nearby_location(hisim center)
{
   hlagrangepoint lpoint;
   hhabitat habitat;

   lpoint = iLagrangePoint.Nearest(iMapEntity.SystemLagrangePoints(), center);
   habitat = iHabitat.Nearest(iMapEntity.SystemHabitats(), center);

   if (Sim.DistanceBetween(habitat, center) < Sim.DistanceBetween(lpoint, center)) {
      return habitat;
   }

   return lpoint;
}



hship create_leader (hmapentity location, hisim operation, hgroup cull_group, string ship_type)
{
   float threat;
   string leader_template, leader_name;
   hfaction faction = iSim.Faction(operation);
   hinifile leader_file;
   hship leader;


   if (tUnderOp.IsOperation(operation)) {
      leader_template = tUnderOp.ShipTemplate(operation);
      leader_name = tUnderOp.Name(operation);
   }else {
      leader_template = tsShipCreation.GetShip(faction, 
                                               tsShipCreation.String2ShipType(ship_type));
      leader_name = tShipName.ShipName("govornment",10000);
   }

   leader_file = INIFile.Create(leader_template);

   if (none == leader_file) {
      debug Debug.PrintString("tPcGuards.create_leader error leader ini file invalid\n");
      return none;
   }

   threat = INIFile.Float(leader_file,"Properties","threat", 40);

   INIFile.Destroy(leader_file);

   leader = tsShip.Create(leader_template, leader_name);

   tsPilotSetup.SetupEscort(leader, 0.9, 0.5);

   iSim.SetFaction(leader, faction);
   Sim.SetCullable(leader, false);

   Sim.PlaceRelativeTo(leader, location, 10km, 0, 0);

   iShip.Attacked(leader);
   iShip.LastAttacker(leader);

   tPcOwner.SetOwner(leader, operation);

   Group.AddSim(cull_group, leader);

   return leader;
}

create_escorts(hisim operation, int fleets, hship leader, hgroup cull_group, string ship_type)
{
   float threat;
   string escort_template;
   hfaction faction = iSim.Faction(operation);
   hinifile escort_file;
   int i, total;
   hship escort;

   escort_template = tsShipCreation.GetShip(faction, tsShipCreation.String2ShipType(ship_type));
   escort_file = INIFile.Create(escort_template);

   if (none == escort_file) {
      debug Debug.PrintString("tPcGuards.create_escort error escort ini file invalid\n");
      return;
   }

   threat = INIFile.Float(escort_file,"Properties","threat", 40);
   INIFile.Destroy(escort_file);

   total = fleets/threat;

   for (i=0;i<total;++i) {
      escort = tsShip.Create(escort_template, tShipName.ShipName("govornment",10000));

      tsPilotSetup.SetupEscort(escort, 0.9, 0.5);

      iSim.SetFaction(escort, faction);
      Sim.SetCullable(escort, false);

      Sim.PlaceRelativeTo(escort, leader, 2km, 0, 0);

      iShip.Attacked(escort);
      iShip.LastAttacker(escort);

      tPcOwner.SetOwner(escort, operation);

      Group.AddSim(cull_group, escort);
   }

}

set filter_feeling(set ships, hfaction faction, float feeling)
{
   set filtered;
   hship ship;
   hfaction ship_faction;

   while (!Set.IsEmpty(ships)) {
      ship = iShip.Cast(Set.FirstElement(ships));
      Set.Remove(ships, ship);
      ship_faction = iSim.Faction(ship);

      if (iFaction.Feeling(ship_faction, faction) < feeling) {
         Set.Add(filtered, ship);
      }
   }

   return filtered;
}

eCSScriptState change_state(eCSScriptState state, eCSScriptState new_state, bool debug_on)
{
   if (debug_on) {
      debug Debug.PrintString(String.FormatStrStr("tPcGuards state change %s->%s\n",
                                                  state2string(state),
                                                  state2string(new_state)));
   }

   return new_state;
}



string state2string(eCSScriptState state)
{
   switch (state) {
   case eCS_Init:
      return "eCS_Init";
      break;
   case eCS_ToDestination:   
      return "eCS_ToDestination";
      break;
   case eCS_WaitApproach:   
      return "eCS_WaitApproach";
      break;
   case eCS_CheckNearby:   
      return "eCS_CheckNearby";
      break;
   case eCS_Attacked:   
      return "eCS_Attacked";
      break;
   case eCS_Fight:   
      return "eCS_Fight";
      break;
   case eCS_Distress:   
      return "eCS_Distress";
      break;
   case eCS_Dead:   
      return "eCS_Dead";
      break;
   case eCS_Cull:   
      return "eCS_Cull";
      break;
   default:
      break;
   }

   return "eCS_Invalid";

}


/*   

THIS MOD IS NOT MADE, DISTRIBUTED, OR SUPPORTED BY INFOGRAMES
OR PARTICLE SYSTEMS LTD. 

ELEMENTS TM & (C) INFOGRAMES AND PARTICLE SYSTEMS LTD.
*/
