//*******************************************************************************************/
//
//    tsPcCargoShip.pog
//
//    This module implements a wandering trade group. They will venture from
//    station to station moving cargo pods. They try to follow the suggested
//    trades. They use the pod spewer.
//
//    March, 2006, jon freise
//******************************************************************************************/

package tsPcCargoShip;

uses iShip, Global, Object, Sim, Input, iMapEntity, Math, iAI, Task, Debug, iFaction, iSim, 
   iFactionScript, iComms, INIFile, iUtilities, iPilotSetup,
   iConversation, iFormation, Group, Text, iEmail, State, 
   iTrafficCreation, iRangeCheck,iRemotePilot, iRegion, iMissionTracker, 
   iWingmen, iCargoScript, iShipCreation, iHUD, iScriptedOrders, iStation, 
   iStartSystem, iObjectives, iMultiplay, iCutsceneUtilities,iDirector, 
   iEscort, iLagrangePoint, iMusic, iGame, Stream, iGUI,
   ABB_Common,
   ECargoTypes,

   tsStationEnum,
   tsEconUtil,
   tsEconomy,
   tsStation,
   tsStationFilter,
   tsLRoot,
   tsLTrade,
   tsLProduction,
   tsMoney,
   tsTime,
   tsFaction,
   tsPodUtil,
   tsSpewerOps,
   tsPilotSetup,
   tsShipCreationEnum,
   tsShipCreation,
   tsShipName,
   tsString,
   tsShip;



provides PogCreate,
         PogStart;


enum eCSScriptState
{
   eCS_Init,
   eCS_ToDestination,
   eCS_WaitApproach,
   eCS_WaitQueue,
   eCS_ToDock,
   eCS_WaitDocking,
   eCS_Docked,
   eCS_Unload,
   eCS_WaitUnload,
   eCS_Load,
   eCS_WaitLoad,
   eCS_ChooseCargo,
   eCS_ChooseDestination,
   eCS_AbandonStation,
   eCS_Dead,
   eCS_Escort,
   eCS_Cull
};


prototype setup_ship(hisim marker);

prototype bool dock_freighter(hship cargo_ship, hhabitat station);

prototype set ShipPodList(hsim ship);

prototype task TradeWander(hgroup cargo_fleet, hhabitat start_station);

prototype set create_output_cargo(hhabitat station, hship cargo_ship, int number_of_pods);

prototype set create_input_cargo(hhabitat station, hship cargo_ship, int number_of_pods);

prototype set create_supply_cargo(hhabitat station, hship cargo_ship, int number_of_pods);

prototype set create_cargo(list cargo_list, string faction_name, int number_of_pods);

prototype hhabitat find_station(hhabitat current_station, int type);

prototype string state2string(eCSScriptState state);

prototype eCSScriptState change_state(eCSScriptState state, eCSScriptState new_state, bool debug_on);



hsim PogCreate(string template_name, string object_name)
{

   hinifile object_file;
   string item_template, pog_class, start_function, name;
   hsim item;
   htask current_task;
   htask parent_task;

   debug Debug.PrintString("tsPcCargoShip.PogCreate\n");


   object_file = INIFile.Create(template_name);

   if (none == object_file) {
      debug {
         Debug.PrintString("tsPcCargoShip.PogCreate, error failed to find object file\n");
      }

      return none;
   }

   // Pull needed items out of template file. Create the object.
   // Attach them
   pog_class = INIFile.String(object_file, "PogClass","name","none");


   ///********************
   // This block of code is class dependent. The rest must be done to adhere
   // to the pog object calling conventions.

   INIFile.Destroy(object_file);

   item = Sim.Create("ini:/sims/nav/waypoint","cargo_script_marker");
   Sim.SetCullable(item, false);

   if (none == item) {
      debug {
         Debug.PrintString("tsPcCargoShip.PogCreate, bad object template\n");
      }
      return none;
   }
   ///********************


   // All 
   Object.AddStringProperty(item, "gt_pog_object_class", pog_class);
   Object.AddStringProperty(item, "gt_pog_object_template", template_name);

      
   return item;
}


/*
This function is called after the ship has been placed. 

*/
task PogStart(hsim pog_object)
{

   debug Debug.PrintString("tsPcCargoShip: starting\n");

   ///***************************************
   // This part of the start code is object dependent. The prior pieces must
   // be done to adhere to the pog class calling convention.

   setup_ship(iSim.Cast(pog_object));

   ///***************************************
}


setup_ship(hisim marker)
{
   hship ship, escort;
   hship pod;
   hhabitat station, start_station;
   hship player = iShip.FindPlayerShip();
   hgroup trade_group = Group.Create();
   hgroup escort_group = Group.Create();
   hgroup pod_group = Group.Create();
   hfaction station_faction;
   int station_type, i, total_escort, pod_count;
   set habitats, cargo_set;
   string name, ship_template;

   habitats = iMapEntity.SystemHabitats();
   start_station = iHabitat.Nearest(habitats, marker);
   station_faction = iSim.Faction(start_station);

   station = start_station;

   name = tsShipName.ShipName( "general", Math.RandomInt(0, 343));
   ship_template = tsShipCreation.GetShip(station_faction, EST_FreightAll);

   ship = tsShip.Create("ini:/sims/ships/utility/freighter","CargoTest");

   ship = tsShip.Create(ship_template, name);

   if (ship == none) {
      debug Debug.PrintString("tsCargoShip.TestScript ship failed to create\n");
      debug Debug.PrintString(ship_template);
      debug Debug.PrintString(" template\n");
      return;
   }

   tsPilotSetup.SetupCargo(ship, 0.9, 0.5);
   iSim.SetFaction(ship, station_faction);
   Sim.SetCullable(ship, false);

   // Let us see this ship far away.
   //iSim.SetSensorVisibility(ship, true);

   Sim.PlaceNear(ship, station, Math.Random(10km, Global.Float("gt_distance_culling")));

   Group.AddSim(trade_group, ship);

   // Now create the cargo and dock it to the freighter.
   pod_count = Math.RandomInt(1,Set.ItemCount(tsPodUtil.DockPorts(ship)));
   cargo_set = create_input_cargo(station, ship, pod_count);
   
   while (!Set.IsEmpty(cargo_set)) {
      pod = iShip.Cast(Set.FirstElement(cargo_set));
      Set.Remove(cargo_set, pod);

      iSim.Dock(pod, ship);
   }

   // Now create the escort ships. One escort for every 6 pods.
   total_escort = (pod_count+3)/6;

   for (i=0;i<total_escort;++i) {
      name = tsShipName.ShipName( "general", Math.RandomInt(0, 343));
      ship_template = tsShipCreation.GetShip(station_faction, EST_CombatLight);

      escort = tsShip.Create(ship_template, name);

      tsPilotSetup.SetupEscort(escort, 0.9, 0.5);

      iSim.SetFaction(escort, station_faction);
      Sim.SetCullable(escort, false);

      // Let us see this escort far away.
      //iSim.SetSensorVisibility(escort, true);

      Sim.PlaceRelativeTo(escort, ship, 2km, 0, 0);

      iShip.Attacked(escort);
      iShip.LastAttacker(escort);

      Group.AddSim(trade_group, escort);
   }


   // We don't need the center mark any longer.
   Sim.Destroy(marker);


   Task.Detach(start TradeWander(trade_group, iHabitat.Cast(start_station)));
}


// This function will take the current cargo fleet and start trading
// at the start station. It will keep moving from station to station
// through the cluster until it is far from the player.

// the script should not be called until the fleet is placed into the game.
// It will move the the start station and unload an cargo it is currently
// carrying.
task TradeWander(hgroup cargo_fleet, hhabitat start_station)
{
   eCSScriptState state = eCS_Init;
   hhabitat station;
   bool result;
   hship cargo_ship;
   set cargo_pods;
   int next_station_type;
   float spacing;
   float delay_time = 3;
   bool debug_on = Global.Bool("gt_debug_tpccargoship");
   int timer, ports, wait_count;
   hship player;

   // Search the Group for the cargo ship.
   cargo_ship = iShip.Cast(Group.Leader(cargo_fleet));

   if (none == cargo_ship) {
      debug Debug.PrintString("tsCargoShip.CargoScript group empty\n");
      return;
   }

   while (1) {
      debug_on = Global.Bool("gt_debug_tpccargoship");

      player = iShip.FindPlayerShip();
      if (Sim.IsDead(cargo_ship)) {
         if (eCS_Cull != state) {
            state = change_state(state, eCS_Dead, debug_on);
         }
      }else if (Sim.DistanceBetween(iShip.Cast(Group.Leader(cargo_fleet)), player) > 1000km) {
         ++timer;
         if (timer > (30/delay_time)) {
            state = change_state(state, eCS_Cull, debug_on);
         }
      }else {
         timer = 0;
      }

      switch (state) {
      case eCS_Init:
         // Where are we? Do we need to move to the 
         // start station? Are we already nearby?
         // Can we just start the unload process?

         spacing = iUtilities.GetLargestShipRadius( cargo_fleet);
         iEscort.Wedge( cargo_fleet, spacing, 50km, true );

         next_station_type = HT_Invalid;
         station = start_station;
         state = change_state(state, eCS_ToDestination, debug_on);
         break;

      case eCS_ToDestination:
         
         // Send the cargo ship to the current station.
         iAI.PurgeOrders(cargo_ship);
         iAI.GiveApproachOrderAdvanced( cargo_ship,
                                        station,
                                        20km,
                                        21km,
                                        true);

         state = change_state(state, eCS_WaitApproach, debug_on);
         break;

      case eCS_WaitApproach:
         // Wait here until the AI has halted.
         if (OT_None == iAI.CurrentOrderType(cargo_ship)) {
            // Requesting docking clearance.
            iComms.Shout(cargo_ship, "", tsString.CommsStringRandom("pccgo_cargoship_requesting_cargo_dock","",5));
            state = change_state(state, eCS_WaitQueue, debug_on);
            wait_count = 0;
         }
         break;

      case eCS_WaitQueue:
         if (wait_count > 30) {

            iComms.Shout(station, "", tsString.CommsStringRandom("pccgo_cargoship_docking_cleared","",5));
            // Wait here for a chance to use the freight port.
            state = change_state(state, eCS_ToDock, debug_on);
         }
         ++wait_count;
         break;

      case eCS_ToDock:
         next_station_type = HT_Invalid;

         // Give the order to dock.
         result = dock_freighter(cargo_ship, station);
         if (result == true) {
            state = change_state(state, eCS_WaitDocking, debug_on);
         } else {
            // Either a timeout or lack of dockport
            // caused a failure. Pick a new station
            // to try again.
            state = change_state(state, eCS_AbandonStation, debug_on);
         }
         break;

      case eCS_WaitDocking:
         // Wait here while the cargo ship docks.

         if (iSim.IsDockedToStructure(cargo_ship, iSim.Cast(station))) {
            state = change_state(state, eCS_Docked, debug_on);
         }else if (OT_Dock != iAI.CurrentOrderType( cargo_ship )) {
            // Reissue the order, if the ship fails to dock.
            state = change_state(state, eCS_ToDock, debug_on);
            // if this happens several times, the dockports are broken,
            // just abandon the station.
         }
         break;

      case eCS_Docked:
         // We are now attached to the station. This station
         // can be cleared from the destination location.

         tsSpewerOps.Initialize(cargo_ship, station);
         state = change_state(state, eCS_Unload, debug_on);
         break;

      case eCS_Unload:
         cargo_pods = ShipPodList(cargo_ship);

         if (Set.IsEmpty(cargo_pods)) {
            debug Debug.PrintString("tsCargoShip unload set empty\n");
            state = change_state(state, eCS_ChooseCargo, debug_on);
         }else{
            iComms.Shout(cargo_ship, "", tsString.CommsStringRandom("pccgo_cargoship_starting_unload","",5));
            tsSpewerOps.UnloadShip(cargo_ship, station, cargo_pods);         
            state = change_state(state, eCS_WaitUnload, debug_on);

         }
         break;

      case eCS_WaitUnload:
         if (tsSpewerOps.IsFinished(cargo_ship)) {
            state = change_state(state, eCS_ChooseCargo, debug_on);
         }
         break;


      case eCS_Load:
         ports = Set.ItemCount(tsPodUtil.DockPorts(cargo_ship));
         cargo_pods = create_output_cargo(station, cargo_ship, ports);

         if (!Set.IsEmpty(cargo_pods)) {
            iComms.Shout(cargo_ship, "", tsString.CommsStringRandom("pccgo_cargoship_starting_load","",5));

            tsSpewerOps.LoadShip(cargo_ship, station, cargo_pods);
            state = change_state(state, eCS_WaitLoad, debug_on);
         }else {
            state = change_state(state, eCS_ChooseDestination, debug_on);
         }

         break;
      case eCS_WaitLoad:
         if (tsSpewerOps.IsFinished(cargo_ship)) {
            state = change_state(state, eCS_ChooseDestination, debug_on);
         }
         break;



      case eCS_ChooseCargo:
         // Here we make the choice if we are going to load some cargo.
         // If we do, we choose the next station.
         state = change_state(state, eCS_Load, debug_on);
         break;

      case eCS_ChooseDestination:
         station = find_station(station, next_station_type);
         state = change_state(state, eCS_ToDestination, debug_on);
         break;



      case eCS_AbandonStation:
         // An error happened trying to dock or move cargo 
         // at this station. Move to another station.

         iComms.Shout(cargo_ship, "", tsString.CommsStringRandom("pccgo_cargoship_abandon_dock","",5));

         // Make sure we are removed from this stations queue.
         station = find_station(station, next_station_type);
         state = change_state(state, eCS_ToDestination, debug_on);
         break;


      case eCS_Dead:
         // The freighter is dead. Promote another ship leader.
         // Then switch to escort state to allow fighting
         // to continue.
         // If all the escorts are dead, go to cull state.

         Group.RemoveSim(cargo_fleet, cargo_ship);
         cargo_ship = iShip.Cast(Group.Leader(cargo_fleet));
         if (none == cargo_ship) {
            state = change_state(state, eCS_Cull, debug_on);
         }else {
            state = change_state(state, eCS_Escort, debug_on);
         }
         break;

      case eCS_Escort:
         // The cargo ship is gone, we just wait here while the escorts fight it out with
         // the attackers. As ships are killed, they will be promoted.
         // Eventually all ships will die, and the script will enter
         // the eCS_Cull state.
         break;

      case eCS_Cull:
         // Freighter should allow itself to be culled. Do it here to make sure not in the middle 
         // of any other script actions.
         // Some explanation:
         // We don't cull the ships, just in case the player is somehow near one.
         // Instead, we just allow them to be culled at this point.
         // They will vanish as soon as they are safely out of player sight.
         iAI.PurgeOrders(cargo_fleet);
         ABB_Common.SetCullableGroup(cargo_fleet, true);
         Group.Destroy(cargo_fleet, false);
         debug atomic {
            Debug.PrintString("tsCargoShip all ships culled, exit\n");
         }
         return;
         break;

      default:
         state = change_state(state, eCS_Init, debug_on);
         break;
      }

      // A bit of delay allows messages to print between state
      // changes. And removes the feeling of unnaturally fast reactions.
      Task.Sleep(Task.Current(), delay_time);
   }
}


eCSScriptState change_state(eCSScriptState state, eCSScriptState new_state, bool debug_on)
{
   if (debug_on) {
      debug Debug.PrintString(String.FormatStrStr("tsCargoShip state change %s->%s\n",
                                                  state2string(state),
                                                  state2string(new_state)));
   }

   return new_state;
}



bool dock_freighter(hship cargo_ship, hhabitat station)
{
   hdockport station_dock, ship_dock;

   set dockports;

   // We just skip over stations that have no pod handling facility.
   if (!iHabitat.HasSpewer(station)) {
      debug Debug.PrintString("habitat has no spewer\n");
      return false;
   }

   // Find the stations main freight port
   dockports = iDockport.DockportsCompatibleWith( iSim.Cast(station),
                                                  DT_Freight,
                                                  DS_Free);
   station_dock = iDockport.Cast(Set.FirstElement(dockports));

   dockports = iDockport.DockportsCompatibleWith( iSim.Cast(cargo_ship),
                                                  DT_Freight,
                                                  DS_Free);

   ship_dock = iDockport.Cast(Set.FirstElement(dockports));


   if ((none == station_dock)||(none == ship_dock)) {
      debug Debug.PrintString("dock_freighter no docks found\n");
      return false;
   }

   // Give the ship the order to dock.

   iAI.PurgeOrders(cargo_ship);
   iAI.GiveDockOrderWithDockport( ship_dock, station_dock );

   return true;
}


// Returns all cargo pods docked to a ship.
set ShipPodList(hsim ship)
{
   set pods;
   set docked_pods;
   hsim child;

   // Search all subsims for cargo pods.
   
   pods = Sim.Children(ship);

   while (!Set.IsEmpty(pods)) {
      child = Sim.Cast(Set.FirstElement(pods));
      Set.Remove(pods, child);

      if (T_CargoPod == iSim.Type(child)) {
         Set.Add(docked_pods, child);
      }
   }

   return docked_pods;
}

// Picks out a number random cargo from the stations production list and returns
// those pods

set create_output_cargo(hhabitat station, hship cargo_ship, int number_of_pods)
{
   list cargo_list;
   set empty_set;

   cargo_list = List.FromSet(tsEconomy.StationProducedCargo(iSim.Cast(station)));

   if (List.IsEmpty(cargo_list)) {
      return empty_set;
   }

   return create_cargo(cargo_list, iFaction.Name(iSim.Faction(cargo_ship)), number_of_pods);
}


set create_input_cargo(hhabitat station, hship cargo_ship, int number_of_pods)
{
   list cargo_list;
   set empty_set;

   cargo_list = List.FromSet(tsEconomy.StationUsedCargo(iSim.Cast(station)));

   if (List.IsEmpty(cargo_list)) {
      return empty_set;
   }

   return create_cargo(cargo_list, iFaction.Name(iSim.Faction(cargo_ship)), number_of_pods);
}


set create_supply_cargo(hhabitat station, hship cargo_ship, int number_of_pods)
{
   list cargo_list;
   set empty_set;

   cargo_list = List.FromSet(tsEconomy.StationSupplyCargo(iSim.Cast(station)));

   if (List.IsEmpty(cargo_list)) {
      return empty_set;
   }

   return create_cargo(cargo_list, iFaction.Name(iSim.Faction(cargo_ship)), number_of_pods);
}



set create_cargo(list cargo_list, string faction_name, int number_of_pods)
{
   int total, i;
   set pods;
   hship pod;
   hcargo cargo;
   
   total = number_of_pods;
   if (total<0) {
      total = 0;
   }

   for (i=0;i<total;++i) {
      cargo = iCargo.Cast(List.GetNth(cargo_list, Math.Random(0, List.ItemCount(cargo_list))));
      pod = iShip.Cast(tsPodUtil.CreateCargoPod(tsEconUtil.CargoType(cargo), faction_name, faction_name));
      Sim.SetCullable(pod, false);
      Set.Add(pods, pod);
   }

   return pods;
}


int read_next_station(hhabitat station)
{
   hinifile econ_file = INIFile.Create("ini:/station_cargo");
   string station_key;
   string next_station;

   station_key = tsEconUtil.StationIntToString(tsLProduction.GetType(iSim.Cast(station)));
   next_station = INIFile.String(econ_file, station_key,"next_station","");

   INIFile.Destroy(econ_file);

   return tsEconUtil.StationStringToEnum(next_station);
}


// This function will always return a station. If it cannot find a station of the 
// proper type, it will just return the first station.
// It always rejects destroyed or hidden stations.

// The stations should be filtered first on not destroyed and not hidden.
// Then they should be filtered on type. If none of those exist, then use them all.
// Then they should be filtered on faction, to weed out hostile factions.

hhabitat find_station(hhabitat current_station, int type)
{
   set habitats;
   hhabitat station;
   hship player = iShip.FindPlayerShip();

   habitats = iMapEntity.SystemHabitats();
   Set.Remove(habitats, current_station);

   // Find the second nearest habitat, and place the test ship there.
   habitats = tsStationFilter.OnPodSpewer(tsStationFilter.OnStatus(habitats, ESS_Normal));

   station = iHabitat.Random(habitats);

   return station;
}





string state2string(eCSScriptState state)
{
   switch (state) {
   case eCS_Init:
      return "eCS_Init";
      break;
   case eCS_ToDestination:   
   return "eCS_ToDestination";
      break;
   case eCS_WaitApproach:   
      return "eCS_WaitApproach";
      break;
   case eCS_WaitQueue:   
   return "eCS_WaitQueue";
      break;
   case eCS_ToDock:   
   return "eCS_ToDock";
      break;
   case eCS_WaitDocking:   
   return "eCS_WaitDocking";
      break;
   case eCS_Docked:   
   return "eCS_Docked";
      break;
   case eCS_Unload:   
   return "eCS_Unload";
      break;
   case eCS_WaitUnload:   
   return "eCS_WaitUnload";
      break;
   case eCS_Load:   
   return "eCS_Load";
      break;
   case eCS_WaitLoad:   
   return "eCS_WaitLoad";
      break;
   case eCS_ChooseCargo:   
   return "eCS_ChooseCargo";
      break;
   case eCS_ChooseDestination:
      return   "eCS_ChooseDestination";
      break;
   case eCS_AbandonStation:   
   return "eCS_AbandonStation";
      break;
   case eCS_Dead:   
   return "eCS_Dead";
      break;
   case eCS_Escort:   
   return "eCS_Escort";
      break;
   case eCS_Cull:   
   return "eCS_Cull";
      break;
   default:
      break;
   }

   return "eCS_Invalid";

}

/* 
THIS MOD IS NOT MADE, DISTRIBUTED, OR SUPPORTED BY INFOGRAMES
OR PARTICLE SYSTEMS LTD. 

ELEMENTS TM & (C) INFOGRAMES AND PARTICLE SYSTEMS LTD.
*/









