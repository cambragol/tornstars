//*******************************************************************************************/
//
// tEPlayerOrders.pog
//
// This file implements player wingman commands.
// 
// 
// 
//
// June 2003, Jon Freise
//******************************************************************************************/

package tEPlayerOrders;

uses    Sim,
iShip,
iSim,
iPilotSetup,
Debug,
Global,
GUI,
iDirector,
iGUI,
iHUD,
iHabitat,
iMapEntity,
INIFile,
Input,
List,
Object,
String,
Task,
Text,
iUtilities,
iCargo,
iInventory,
iComms,
iConversation,
iAi,
Math,
CargoTypes,
tEpicFleet,
tFormation,
tPodUtil,
tEFaction,
tStationEnum,
tStation,
tLProduction,
tMegaTrucking;



provides 

Halt,
DefendMe,

AttackTarget,
DefendTarget,

DockTarget,
   Undock,
ApproachTarget,

CaptureShip,
DockPod,

CollectPods,
UndockAllPods,

ShipToGroup,
RemoveShip,

GroupExists,
OrderTarget,

SetOrderTarget,
FuelTarget,
FuelDrainTarget,
TankersFillFleet,

ScanSky, 
ProspectAsteroid,
MineAsteroid,
   DetachAsteroid;


prototype bool DockPodSet(int group, set pods);

prototype bool station_known(int station_type);

prototype bool is_mine(hhabitat station);

prototype task mining_task(hship miner, hhabitat target);

prototype task prospecting_task(hship prospector, hhabitat target);

prototype bool is_valid_target(hisim target);

prototype bool is_valid_destination(hisim target);

// These functions signal to the reputation code that the
// wingman is attacking a target intentionally. It is meant
// to keep from charging the player in unintentional attacks.

hisim OrderTarget(hship ship) {
   return iSim.Cast(Object.HandleProperty(ship,"gtWingTarget"));
}


SetOrderTarget(hship ship, hisim target) {

   Object.AddHandleProperty(ship,"gtWingTarget", target);
}


int PriorOrder(hship ship)
{
   return Object.IntProperty(ship,"gt_prior_order");
}

SetPriorOrder(hship ship, int order_type)
{
   Object.AddIntProperty(ship,"gt_prior_order", order_type);
}

bool GroupExists(int group) {

   list fleet = tEpicFleet.ReturnGroup(group);

   if (List.IsEmpty(fleet)) {
      return false;
   }

   return true;
}


// This is the one command that can be given to ships at any distance.
// Ships that are halted will not return to formation with the player
// the player must order them to return to formation.

// This is done by not clearing the orders, but giving the
// ship orders to formate with a waypoint.
bool Halt(int group) {
   list fleet;
   set near_fleet;

   int i, total;
   hisim waypoint;
   hship ship;
   hship player = iShip.FindPlayerShip();

   fleet = tEpicFleet.ReturnGroup(group);


   total = List.ItemCount(fleet);
   for (i=0;i<total;++i) {
      ship = iShip.Cast(List.GetNth(fleet,i));
      iAI.PurgeOrders(ship);

      waypoint = iSim.Cast(Sim.Create("ini:/sims/nav/waypoint","halt point"));
      Sim.SetCullable(waypoint, false);
      Sim.PlaceAt(waypoint, ship);
      Sim.CopyOrientation(waypoint, ship);
      iAI.PurgeOrders(ship);
      iAI.GiveFormateOrder( ship, waypoint, 0.0, 0.0,0.0 );

      SetPriorOrder(ship, OT_None);

      debug {
         Debug.PrintHandle(ship);
         Debug.PrintString(" Halt Order\n");
      }
   }

   iComms.Shout(List.Head(fleet), "", "epo_halt_order_ack");
   return true;
}



bool AttackTarget(int group, hisim target) {
   list fleet;
   int i, total;
   hship ship, group_leader;
   hship player = iShip.FindPlayerShip();
   hfaction player_faction = iFaction.Find("Player");

   fleet = tEpicFleet.ReturnGroup(group);
   group_leader = iShip.Cast(List.Head(fleet));

   if (none == target){
      iComms.Shout(group_leader, "", "epo_refuse_no_target");
      return false;
   }

   if (!is_valid_target(target)){
      iComms.Shout(group_leader, "", "epo_refuse_no_target");
      return false;
   }


   if (Global.Float("gt_distance_wakeup") < Sim.DistanceBetween(target, player)) {
      iComms.Shout(group_leader, "", "epo_refuse_target_far");
      return false;
   }

   if (player_faction == iSim.Faction(iSim.Cast(target))) {
      iComms.Shout(group_leader, "", "epo_refuse_player_ship_target");
      return false;
   }

   fleet = List.FromSet(iSim.SimsInRadiusFromSet(Set.FromList(tEpicFleet.ReturnGroup(group)), 
                                                 player, Global.Float("gt_distance_wakeup"), TM_Ship));

   total = List.ItemCount(fleet);

   // There are no ships nearby, so tell player that will not work.
   if (total == 0) {
      iComms.Shout(group_leader, "", "epo_refuse_player_far");
      return false;
   }

   for (i=0;i<total;++i) {
      ship = iShip.Cast(List.GetNth(fleet,i));

      iAI.PurgeOrders(ship);
      iAI.GiveAttackOrder(ship, target);

      SetOrderTarget(ship, iSim.Cast(target));

      SetPriorOrder(ship, OT_Attack);
   }

   iComms.Shout(ship, "", "epo_attack_target_ack");
   return true;
}


// The approach me should work if the ships are in the same system as the player.
bool DefendMe(int group ) {
   list fleet;
   int i, total;
   float distance;
   hship ship;
   hship player = iShip.FindPlayerShip();
   bool out_system;

   fleet = tEpicFleet.ReturnGroup(group);

   total = List.ItemCount(fleet);

   out_system = false;

   for (i=0;i<total;++i) {
      ship = iShip.Cast(List.GetNth(fleet,i));

      if (iSim.WorldName(ship) == iSim.ActiveWorld()) {

         iAI.PurgeOrders(ship);
         iAI.GiveEscortOrder(ship, 
                             player,
                             tFormation.Xpos(ship),
                             tFormation.Ypos(ship),
                             tFormation.Zpos(ship),
                             50km);

         SetPriorOrder(ship, OT_Formate);
      } else {
         iComms.Shout(ship, "", "epo_out_of_system");
         iHUD.Print("ship out of system");
         out_system = true;
      }

   }

   if (!out_system) {
      iComms.Shout(List.Head(fleet), "", "epo_formate_player_ack");
   }

   return true;
}



bool DefendTarget(int group, hisim target) {
   list fleet;
   int i, total;
   float distance;
   hship ship, group_leader;
   bool near;
   hship player = iShip.FindPlayerShip();

   fleet = tEpicFleet.ReturnGroup(group);
   group_leader = iShip.Cast(List.Head(fleet));

   if (none == target){
      iComms.Shout(group_leader, "", "epo_refuse_no_target");
      return false;
   }

   if (!is_valid_target(target)){
      iComms.Shout(group_leader, "", "epo_refuse_no_target");
      return false;
   }

   if (Global.Float("gt_distance_wakeup") < Sim.DistanceBetween(target, player)) {
      iComms.Shout(group_leader, "", "epo_refuse_target_far");
      return false;
   }

   fleet = List.FromSet(iSim.SimsInRadiusFromSet(Set.FromList(fleet), 
                                                 player, Global.Float("gt_distance_wakeup"), TM_Ship));

   total = List.ItemCount(fleet);

   // There are no ships nearby, so tell player that will not work.
   if (total == 0) {
      iComms.Shout(group_leader, "", "epo_refuse_player_far");
      return false;
   }

   for (i=0;i<total;++i) {
      ship = iShip.Cast(List.GetNth(fleet,i));

      iAI.PurgeOrders(ship);

      iAI.GiveEscortOrder(ship, 
                          target,
                          tFormation.Xpos(ship),
                          tFormation.Ypos(ship),
                          tFormation.Zpos(ship),
                          50km);

      SetPriorOrder(ship, OT_Formate);
   }

   iComms.Shout(List.Head(fleet), "", "epo_defend_target_ack");
   return true;
}


bool DockTarget(int group, hisim target) {
   list fleet;
   int i, total;
   hship ship, group_leader;
   hship player = iShip.FindPlayerShip();

   fleet = tEpicFleet.ReturnGroup(group);
   group_leader = iShip.Cast(List.Head(fleet));


   if (none == target){
      iComms.Shout(group_leader, "", "epo_refuse_no_target");
      return false;
   }

   if (!is_valid_target(target)){
      iComms.Shout(group_leader, "", "epo_refuse_no_target");
      return false;
   }

   if (Global.Float("gt_distance_wakeup") < Sim.DistanceBetween(target, player)) {
      iComms.Shout(group_leader, "", "epo_refuse_target_far");
      return false;
   }


   fleet = List.FromSet(iSim.SimsInRadiusFromSet(Set.FromList(fleet), 
                                                 player, Global.Float("gt_distance_wakeup"), TM_Ship));


   total = List.ItemCount(fleet);

   // There are no ships nearby, so tell player that will not work.
   if (total == 0) {
      iComms.Shout(group_leader, "", "epo_refuse_player_far");
      return false;
   }

   for (i=0;i<total;++i) {
      ship = iShip.Cast(List.GetNth(fleet,i));

      iAI.PurgeOrders(ship);
      iAI.GiveDockOrder(ship, target);

      SetPriorOrder(ship, OT_Dock);

      debug {
         Debug.PrintHandle(ship);
         Debug.PrintString(" Dock Order\n");
         Debug.PrintHandle(target);
         Debug.PrintString(" Target\n");

      }
   }

   iComms.Shout(List.Head(fleet), "", "epo_dock_target_ack");
   return true;
}



bool Undock(int group) {
   list fleet;
   int i, total;
   hship ship, group_leader;
   hship player = iShip.FindPlayerShip();

   fleet = tEpicFleet.ReturnGroup(group);
   group_leader = iShip.Cast(List.Head(fleet));


   fleet = List.FromSet(iSim.SimsInRadiusFromSet(Set.FromList(fleet), 
                                                 player, Global.Float("gt_distance_wakeup"), TM_Ship));


   total = List.ItemCount(fleet);

   // There are no ships nearby, so tell player that will not work.
   if (total == 0) {
      iComms.Shout(group_leader, "", "epo_refuse_player_far");
      return false;
   }

   for (i=0;i<total;++i) {
      ship = iShip.Cast(List.GetNth(fleet,i));

      iShip.UndockSelf(ship);      
      iAI.PurgeOrders(ship);
      SetPriorOrder(ship, OT_None);

      debug {
         Debug.PrintHandle(ship);
         Debug.PrintString(" undock Order\n");
      }
   }

   iComms.Shout(List.Head(fleet), "", "epo_undock_ack");
   return true;
}



bool ApproachTarget(int group, hisim target) {
   list fleet;
   int i, total;
   hship ship, group_leader;
   hship player = iShip.FindPlayerShip();

   fleet = tEpicFleet.ReturnGroup(group);
   group_leader = iShip.Cast(List.Head(fleet));

   if (none == target){
      iComms.Shout(group_leader, "", "epo_refuse_no_target");
      return false;
   }

   if (!is_valid_destination(target)){
      iComms.Shout(group_leader, "", "epo_refuse_no_target");
      return false;
   }


   if (iSim.WorldName(target) != iSim.ActiveWorld()) {
      iComms.Shout(group_leader, "", "epo_refuse_target_far");
      return false;
   }

   total = List.ItemCount(fleet);

   for (i=0;i<total;++i) {
      ship = iShip.Cast(List.GetNth(fleet,i));

//      iAI.GiveApproachOrder(ship, target);

      // Try not to have the ships all bash up against one another. Keep thier distance
      // a little better.
      iAI.GiveApproachOrderAdvanced( ship,
                                     target,
                                     1km,
                                     1.5km,
                                     true);

      SetPriorOrder(ship, OT_Approach);

      debug {
         Debug.PrintHandle(ship);
         Debug.PrintString(" Approach Order\n");
         Debug.PrintHandle(target);
         Debug.PrintString(" Target\n");
      }
   }

   iComms.Shout(List.Head(fleet), "", "epo_approach_target_ack");
   return true;
}


// Does the fuel move between tanker and target ship.
// Returns true if the tanker still has more fuel.
bool tanker_fill_ship(hship tanker, hship target) {
   int timer;
   bool full_tanker = true;
   float min_fuel, max_fuel;
   float fuel_left, fuel_needed, fuel_moved, fuel_target, fuel_tanker;
   string response;

   min_fuel = 2 * tEpicFleet.FuelPerJump(tanker);
   max_fuel = tEpicFleet.FuelMax(target);

   atomic {

      // Calculate max that we can fit in target.
      // This is the transfer amount.
      fuel_target = tEpicFleet.Fuel(target);
      fuel_needed = max_fuel - fuel_target;

      // Clip the transfer amount to the minimum the tanker
      // has remaining.
      fuel_tanker = tEpicFleet.Fuel(tanker);
      fuel_left = fuel_tanker - min_fuel;

      if (fuel_left < fuel_needed) {
         fuel_moved = fuel_left;
         full_tanker = false;
      } else {
         fuel_moved = fuel_needed;
      }

      tEpicFleet.SetFuel(tanker, fuel_tanker - fuel_moved);
      tEpicFleet.SetFuel(target, fuel_target + fuel_moved);
   }

   response = String.Join("epo_refueling_finished+",Sim.Name(target));
   iComms.Shout(tanker, "", response);

   return full_tanker;
}

// This function takes a group. It finds the tankers in the group.
// It then keeps filling ships until all the tankers are empty, or
// all the ships are filled.

bool TankersFillFleet(int group) {
   list group_list, target_list, tanker_list, non_tankers;
   int i, total;
   hship tanker, target, leader;
   hship player = iShip.FindPlayerShip();
   bool filled;

   group_list = tEpicFleet.ReturnGroup(group);
   leader = iShip.Cast(List.Head(group_list));

   // Get a list of all tankers in the order group.
   // Only allow player ships within Global.Float("gt_distance_wakeup") to do the fueling.
   group_list = List.FromSet(iSim.SimsInRadiusFromSet(Set.FromList(tEpicFleet.ReturnGroup(group)), 
                                                      player, Global.Float("gt_distance_wakeup"), TM_Ship));

   total = List.ItemCount(group_list);
   for (i=0;i<total;++i) {
      tanker = iShip.Cast(List.GetNth(group_list, i));

      if (0 != Object.IntProperty(tanker,"tanker")) {
         List.AddTail(tanker_list, tanker);
      }
   }


   if (List.IsEmpty(tanker_list)) {
      // Exit, tell player there are no tankers in that list.
      iComms.Shout(leader, "", "epo_no_tankers_in_group");
      return false;
   }

   // Refuels all player ships in Global.Float("gt_distance_wakeup").
   target_list = List.FromSet(iSim.SimsInRadiusFromSet(Set.FromList(tEpicFleet.PlayerFleet()),
                                                       player, Global.Float("gt_distance_wakeup"), TM_Ship));

   List.AddHead(target_list, player);

   // Get a list of all ships that are not tankers.
   total = List.ItemCount(target_list);
   for (i=0;i<total;++i) {
      target = iShip.Cast(List.GetNth(target_list, i));

      if (1 != Object.IntProperty(target,"tanker")) {
         List.AddTail(non_tankers, target);
      }
   }


   // Find a tanker.

   // While more ships
   // If out of ships, exit.
   // Fuel the ship
   // If the tanker is empty, find a new tanker.
   // If out of tankers, exit

   tanker = iShip.Cast(List.Head(tanker_list));
   List.Remove(tanker_list, tanker);

   total = List.ItemCount(non_tankers);
   for (i=0;i<total;++i) {
      target = iShip.Cast(List.GetNth(non_tankers, i));

      filled = false;

      while (!filled) {
         filled = tanker_fill_ship(tanker, target);

         SetPriorOrder(tanker, OT_Formate);

         // The tanker could not fill the ship, so 
         // find a new tanker.
         if (!filled) {
            if (List.IsEmpty(tanker_list)) {
               // No fuel tankers have fuel left, bail out.
               // Tell the player.
               iComms.Shout(tanker, "", "epo_tankers_empty");
               return false;
            } else {
               tanker = iShip.Cast(List.Head(tanker_list));
               List.Remove(tanker_list, tanker);
            }
         }
      }
   }

   // If we have all the ships filled, exit with success
   iComms.Shout(leader, "", "epo_fleet_fueling_complete");

   return true;
}

// Orders the tanker to formate with the target ship (alongside) and within 2km.

bool FuelTarget(int group, hship target) {
   hfaction player_faction = iFaction.Find("Player");
   list fleet;
   int i, total;
   hship ship, group_leader;
   hship player = iShip.FindPlayerShip();
   float min_fuel, fuel_left;
   bool have_tankers;


   fleet = tEpicFleet.ReturnGroup(group);
   group_leader = iShip.Cast(List.Head(fleet));

   if (none == target) {
      iComms.Shout(group_leader, "", "epo_refuse_no_target");
      return false;
   }

   if (Global.Float("gt_distance_wakeup") < Sim.DistanceBetween(target, player)) {
      iComms.Shout(group_leader, "", "epo_refuse_target_far");
      return false;
   }

   // Only ships can be fueled.
   if (!(TM_Ship & iSim.Type(target))) {
      iComms.Shout(group_leader, "", "epo_refuel_only_ships");
      return false;
   }

   // Only allow the refueling of player ships.
   // this is until all ships are created with the right
   // properties to handle fuel.
   if (player_faction != iSim.Faction(target)) {
      iComms.Shout(group_leader, "", "epo_refuel_player_only");
      return false;
   }

   // Only allow player ships within Global.Float("gt_distance_wakeup") to do the fueling.
   fleet = List.FromSet(iSim.SimsInRadiusFromSet(Set.FromList(tEpicFleet.ReturnGroup(group)), 
                                                 player, Global.Float("gt_distance_wakeup"), TM_Ship));

   // Ship cannot refuel itself.
   List.Remove(fleet, target);
   total = List.ItemCount(fleet);

   // There are no ships nearby, so tell player that will not work.
   if (total == 0) {
      iComms.Shout(group_leader, "", "epo_refuse_player_far");
      return false;
   }

   have_tankers = false;

   for (i=0;i<total;++i) {
      ship = iShip.Cast(List.GetNth(fleet,i));

      if (Object.IntProperty(ship,"tanker") != 0) {

         have_tankers = true;

         min_fuel = 2 * tEpicFleet.FuelPerJump(ship);
         fuel_left = tEpicFleet.Fuel(ship);

         if (fuel_left > min_fuel) {

            SetPriorOrder(ship, OT_Formate);

            debug {
               Debug.PrintHandle(ship);
               Debug.PrintString(" Refule Ship\n");
               Debug.PrintHandle(target);
               Debug.PrintString(" Target\n");
            }

            tanker_fill_ship(ship, target);

            // We found a ship that can do the job.
            // Return true.
            iComms.Shout(ship, "", "epo_refuel_target_ack");
            return true;
         }
      }
   }

   // No ships in this group have the tanker features, or have enough fuel.
   if (!have_tankers) {
      iComms.Shout(group_leader, "", "epo_no_tankers_in_group");
   }else {
      iComms.Shout(group_leader, "", "epo_tankers_empty");
   }

   return false;
}

// Used when the tanker is draining fuel cargo pods.
task take_fuel_task(hship tanker, hship target) {
   int timer;
   bool finished = false;
   float max_fuel, fuel_left, fuel_needed, fuel_used;

   max_fuel = tEpicFleet.FuelMax(tanker);

   while (1) {
      Task.Sleep(Task.Current(), 1.0);
      // Check if we are close to the target vessel.
      // Start pumping fuel.

      if (2km > Sim.DistanceBetween(tanker, target)) {
         atomic {
            // Calc the amount of fuel to transfer in this time
            fuel_used = tEpicFleet.Fuel(tanker);
            fuel_needed = max_fuel - fuel_used;

            if (fuel_needed < 25.0) {
               // We will tranfer last bit of fuel this turn
               // stop pumping.
               finished = true;
            } else {
               fuel_needed = 25.0;
            }

            // Calculate fuel left in pod after we pump some out.
            fuel_left = tEpicFleet.Fuel(target);

            if (fuel_left < fuel_needed) {

               fuel_needed = fuel_left;
               fuel_left = 0.0;
               finished = true;
            } else {
               fuel_left = fuel_left - fuel_needed;
            }

            // Now that we have max transfer amount, move fuel.
            fuel_used = fuel_used + fuel_needed;
            tEpicFleet.SetFuel(tanker, fuel_used);
            tEpicFleet.SetFuel(target, fuel_left);
         }

         if (T_CargoPod & iSim.Type(target)) {
            if (fuel_left < 250.0) {
               // Once the pod is half empty, mark it empty.
               Object.SetIntProperty(target, "cargo", CT_Invalid);
               iUtilities.RenameSim(target,"Cargo_Empty");
            }
         }
      }


      if (OT_Formate != iAI.CurrentOrderType(tanker)) {
         // Check if the player has given this ship new orders.

         debug {
            Debug.PrintString("Player changed orders, fuel drain task exiting\n");
         }

         return;
      }


      if (finished) {
         // return ship to formate with the player. Or whatever the default
         // order for this group currently is.

         iComms.Shout(tanker, "", "epo_fuel_drain_complete");
         return;
      }
   }
}


bool FuelDrainTarget(int group, hship target) {
   list fleet;
   int i, total;
   hship ship, group_leader;
   hship player = iShip.FindPlayerShip();
   hfaction player_faction = iFaction.Find("Player");


   fleet = tEpicFleet.ReturnGroup(group);
   group_leader = iShip.Cast(List.Head(fleet));


   if (none == target){
      iComms.Shout(group_leader, "", "epo_refuse_not_fuel_pod");
      return false;
   }

   if (Global.Float("gt_distance_wakeup") < Sim.DistanceBetween(target, player)) {
      iComms.Shout(group_leader, "", "epo_refuse_target_far");
      return false;
   }

   fleet = List.FromSet(iSim.SimsInRadiusFromSet(Set.FromList(tEpicFleet.ReturnGroup(group)), 
                                                 player, Global.Float("gt_distance_wakeup"), TM_Ship));
   List.Remove(fleet, target);

   total = List.ItemCount(fleet);

   // There are no ships nearby, so tell player that will not work.
   if (total == 0) {
      iComms.Shout(group_leader, "", "epo_refuse_player_far");
      return false;
   }


   if (T_CargoPod & iSim.Type(target)) {
      // The pod must be a fuel pod.

      if (CT_LiquifiedFuel != Object.IntProperty(target,"cargo")) {
         iComms.Shout(group_leader, "", "epo_refuse_not_fuel_pod");
         return false;
      }
   } else {
      // At the moment, we don't allow ships to provide fuel.
      iComms.Shout(group_leader, "", "epo_refuse_not_fuel_pod");
      return false;
   }

   // Only allow draining player owned fuel pods.
   // The player needs to hack other pods to gain control of them.
   if (player_faction != iSim.Faction(target)) {
      iComms.Shout(group_leader, "", "epo_refuse_drain_only_player");
      return false;
   }

   for (i=0;i<total;++i) {
      ship = iShip.Cast(List.GetNth(fleet,i));

      if (Object.IntProperty(ship,"tanker") >= 1) {
         iAI.PurgeOrders(ship);
         iAI.GiveFormateOrder(ship, target, 1.5km, 0.0km, 0.0km);
         SetPriorOrder(ship, OT_Formate);

         debug {
            Debug.PrintHandle(ship);
            Debug.PrintString(" Drain Fuel Ship\n");
            Debug.PrintHandle(target);
            Debug.PrintString(" Target\n");
         }

         // Cargo pods need properties attached to handle being
         // drained. Change type to invalid.
         if (T_CargoPod & iSim.Type(target)) {
            tEpicFleet.SetFuelMax(target, 500.0);
            tEpicFleet.SetFuel(target, 500.0);
         }

         Task.Detach(start take_fuel_task(ship, target));

         // We found a ship that can do the job.
         // Return true.
         iComms.Shout(ship, "", "epo_drain_fuel_ack");
         return true;
      }
   }

   // No ships in this group have the tanker features.
   iComms.Shout(group_leader, "", "epo_refuse_no_tankers");
   return false;
}


// Orders any ship docked to a station to undo docking locks
// and release back to space.
bool DetachAsteroid(int group) {
   list fleet;
   int i, total;
   hship ship, group_leader;
   hhabitat station;
   bool undocked;

   fleet = tEpicFleet.ReturnGroup(group);
   group_leader = iShip.Cast(List.Head(fleet));

   undocked = false;
   // Search the group ships and see if one can be found that is a valid science vessel.
   total = List.ItemCount(fleet);
   for (i=0;i<total;++i) {
      ship = iShip.Cast(List.GetNth(fleet,i));

      station = iHabitat.Nearest(iMapEntity.SystemHabitatsInSystem(iSim.WorldName(ship)), ship);

      if (iSim.IsDockedToStructure(ship, station)) {
         // Undo the docking clamps and let this ship free.
         iSim.SetDockingLock(ship, station, false);
         iSim.Undock(ship, station);

         SetPriorOrder(ship, OT_None);

         iComms.Shout(ship, "", "epo_detach_asteroid");
         undocked = true;
      }
   }

   if (!undocked) {
      iComms.Shout(ship, "", "epo_none_attached");
      return false;
   }

   return true;
}

// iConversation is a blocking function. Scan sky is bound to 
// a keystroke and happening atomically, so if it blocks
// it will lock up the game.

task scan_response (hship ship, bool new_station)
{
      iConversation.OneLiner(ship, "", "epo_scan_sky_ack");

      if (new_station) {
         iConversation.OneLiner(ship, "", "epo_scan_sky_success");
      }else {
         iConversation.OneLiner(ship, "", "epo_scan_sky_failed");
      }
}

// Orders a group with a science vessel to scan for nearby stations and asteroids.
bool ScanSky(int group) {
   hfaction player_faction = iFaction.Find("Player");
   list fleet;
   int i, total;
   hship ship, group_leader;
   hship player = iShip.FindPlayerShip();
   float min_fuel, fuel_left;
   set stations;
   hhabitat station;
   bool found, new_station;


   fleet = tEpicFleet.ReturnGroup(group);
   group_leader = iShip.Cast(List.Head(fleet));

   if (none == group_leader) {
      return false;
   }

   found = false;
   new_station = false;

   // Search the group ships and see if one can be found that is a valid science vessel.
   total = List.ItemCount(fleet);
   for (i=0;i<total;++i) {
      ship = iShip.Cast(List.GetNth(fleet,i));

      if (Object.IntProperty(ship,"scan_range") >= 1) {

         // Find all stations within 500,000km and make them visible.
         stations = iSim.SimsInRadius( ship,
                                       Object.IntProperty(ship, "scan_range"),
                                       T_Station);

         while (!Set.IsEmpty(stations)) {
            station = iHabitat.Cast(Set.FirstElement(stations));
            Set.Remove(stations, station);

            // Reveal the station if it exists, or has ever existed.
            if (tStation.Status(station) != ESS_NeverBuilt) {

               // Reveal the station unless it is a pirate station.
               //if (station_known(tLProduction.GetType(station))) {

               // We used to not reveal pirate stations. Except there is no 
               // way to find pirate stations in the outback areas and the player
               // needs to be to hunt those hunting him, so now we reveal all stations.
               if (!iMapEntity.IsVisibleOnMap(station)) {
                  // If the station is invisible to player, let them see it,
                  // save a note, to tell the player when done.
                  tStation.SetMapVisibility(station, true);
                  new_station = true;
               }
            //}
            }

         }//while nearby stations

         // Prospector found, scan complete, try rest of ships.
         found= true;

      }// if we found a prospector.
   }//for all player wingmen

   // No ships in this group have the science feature
   if (found) {
      Task.Detach(start scan_response(group_leader, new_station));

      return true;
   }else {
      iComms.Shout(group_leader, "", "epo_refuse_no_science_ship");
   }


   return false;
}




// Orders a group with a science vessel to scan for nearby stations and asteroids.
bool MineAsteroid(int group) {
   hfaction player_faction = tEFaction.PlayerFaction();
   hship player = iShip.FindPlayerShip();
   list fleet;
   int i, total;
   hship ship, group_leader;
   hhabitat asteroid;
   bool miner_found;

   fleet = tEpicFleet.ReturnGroup(group);
   group_leader = iShip.Cast(List.Head(fleet));

   asteroid = iHabitat.Nearest(iMapEntity.SystemHabitats(), player);

   if (none == asteroid) {
      iComms.Shout(group_leader, "", "epo_refuse_no_target");
      return false;
   }

   if (Global.Float("gt_distance_wakeup") < Sim.DistanceBetween(asteroid, player)) {
      iComms.Shout(group_leader, "", "epo_refuse_target_far");
      return false;
   }


   if (!is_mine(asteroid)) {
      iComms.Shout(group_leader, "", "epo_refuse_not_mine");
      return false;
   }


   if (player_faction != iSim.Faction(iSim.Cast(asteroid))) {
      iComms.Shout(group_leader, "", "epo_refuse_not_player_mine");
      return false;
   }

   // Only allow player ships within Global.Float("gt_distance_wakeup") to be given the mining command.
   fleet = List.FromSet(iSim.SimsInRadiusFromSet(Set.FromList(tEpicFleet.ReturnGroup(group)), 
                                                 player, Global.Float("gt_distance_wakeup"), TM_Ship));

   total = List.ItemCount(fleet);

   // There are no ships nearby, so tell player that will not work.
   if (total == 0) {
      iComms.Shout(group_leader, "", "epo_refuse_player_far");
      return false;
   }

   miner_found = false;

   for (i=0;i<total;++i) {
      ship = iShip.Cast(List.GetNth(fleet,i));

      if (Object.IntProperty(ship,"miner") >= 1) {

         iAI.PurgeOrders(ship);
         iAI.GiveDockOrder(ship, asteroid);

         SetPriorOrder(ship, OT_Dock);

         debug {
            Debug.PrintHandle(ship);
            Debug.PrintString(" Mine Ship\n");
            Debug.PrintHandle(asteroid);
            Debug.PrintString(" asteroid\n");
         }

         // We found a ship that can do the job.
         // Return true.
         iComms.Shout(ship, "", "epo_miner_docking_ack");

         Task.Detach(start mining_task(ship, asteroid));

         miner_found = true;
      }// found a valid miner.

   }// for each ship in wingman group

   // No ships in the group have the mining attribute.
   if (!miner_found) {
      iComms.Shout(group_leader, "", "epo_no_mining_ships");   
   }

   return false;
}

task mining_task(hship miner, hhabitat target) {
   bool docked = false;

   while (1) {
      Task.Sleep(Task.Current(), 5.0);

      // Check if we are docked, tell the player we touched down.
      if (iSim.IsDockedTo(miner, target)) {

         iConversation.OneLiner(miner,"","epo_mining_rig_docked");
         return;

      } else if (OT_Dock != iAI.CurrentOrderType(miner)) {

         // Check if the player ordered the ship to do something else.
         debug {
            Debug.PrintString("Player changed orders, miner task exiting\n");
         }

         iComms.Shout(miner, "", "epo_mining_dock_cancelled");
         return;
      }
   }
}



// Science vessels can dock to and claim mines for the player.
bool ProspectAsteroid(int group) {
   hfaction empty_faction = tEFaction.EmptyFaction();
   hship player = iShip.FindPlayerShip();
   list fleet;
   int i, total;
   hship ship, group_leader;
   hhabitat asteroid;


   asteroid = iHabitat.Nearest(iMapEntity.SystemHabitats(), player);

   if (none == asteroid) {
      iComms.Shout(group_leader, "", "epo_refuse_no_mine_near");
      return false;
   }

   if (Global.Float("gt_distance_wakeup") < Sim.DistanceBetween(asteroid, player)) {
      iComms.Shout(group_leader, "", "epo_refuse_target_far");
      return false;
   }


   if (!is_mine(asteroid)) {
      iComms.Shout(group_leader, "", "epo_refuse_not_mine");
      return false;
   }


   if (empty_faction != iSim.Faction(iSim.Cast(asteroid))) {
      iComms.Shout(group_leader, "", "epo_refuse_claimed_asteroid");
      return false;
   }

   // Only allow player ships within Global.Float("gt_distance_wakeup") to be given the mining command.
   fleet = List.FromSet(iSim.SimsInRadiusFromSet(Set.FromList(tEpicFleet.ReturnGroup(group)), 
                                                 player, Global.Float("gt_distance_wakeup"), TM_Ship));

   total = List.ItemCount(fleet);

   // There are no ships nearby, so tell player that will not work.
   if (total == 0) {
      iComms.Shout(group_leader, "", "epo_refuse_player_far");
      return false;
   }

   for (i=0;i<total;++i) {
      ship = iShip.Cast(List.GetNth(fleet,i));

      if (Object.IntProperty(ship,"prospector") >= 1) {

         iAI.PurgeOrders(ship);
         iAI.GiveDockOrder(ship, asteroid);

         SetPriorOrder(ship, OT_Dock);

         debug {
            Debug.PrintHandle(ship);
            Debug.PrintString("Prospecting Ship\n");
            Debug.PrintHandle(asteroid);
            Debug.PrintString(" asteroid\n");
         }

         // We found a ship that can do the job.
         // Return true.
         iComms.Shout(ship, "", "epo_prospector_ack");

         Task.Detach(start prospecting_task(ship, asteroid));

         return true;
      }// found a valid prospecting ship

   }// for each ship in wingman group

   // No ships in the group have the mining attribute.
   iComms.Shout(group_leader, "", "epo_refuse_no_prospector");
   return false;
}

// This task gives the player more dialog to let them know what is
// happening with the prospecting ship.

task prospecting_task(hship prospector, hhabitat target) {
   bool docked = false;

   while (1) {
      Task.Sleep(Task.Current(), 5.0);

      // Check if we are docked, tell the player we touched down.
      if (iSim.IsDockedTo(prospector, target)) {

         //iComms.Shout(prospector, "", "ProspectingDocked");

         iConversation.Begin();
         // epo_prospector_attaching, "We are attached to the surface."
         iConversation.Say(prospector,"", "epo_prospector_attaching");
         // epo_prospector_survey_delay, "The survey will take a few days."
         iConversation.Say(prospector,"", "epo_prospector_survey_delay");
         // epo_prospector_send_email, "We will notify you by email when we are done."
         iConversation.Say(prospector,"", "epo_prospector_send_email");

         iConversation.End();


         return;

      } else if (OT_Dock != iAI.CurrentOrderType(prospector)) {


         // Check if the player ordered the ship to do something else.
         debug {
            Debug.PrintString("Player changed orders, prospecting task exiting\n");
         }

         iComms.Shout(prospector, "", "epo_prospector_docking_cancelled");
         return;
      }
   }
}




// Place the ship in a new control group.
bool ShipToGroup(hship ship, int group) {

   if (!tEpicFleet.IsPlayerFleetShip( ship)) {
      // Player tried to order around a non-player ship. Block this.
      // We might allow it someday, but not now.
      iComms.Shout(ship, "", "epo_not_wingman");
      return false;
   }

   if (tEpicFleet.GroupMoveShip(ship, group)) {
      iComms.Shout(ship, "", "epo_move_group_ack");
      return true;
   }

   iComms.Shout(ship, "", "epo_refuse_group_change");
   return false;
}



// Move the ship to group zero.
bool RemoveShip(hship ship) {

   if (!tEpicFleet.IsPlayerFleetShip( ship)) {
      // Player tried to order around a non-player ship. Block this.
      // We might allow it someday, but not now.
      iComms.Shout(ship, "", "epo_not_wingman");
      return false;
   }

   if (tEpicFleet.GroupMoveShip(ship, 0)) {
      iComms.Shout(ship, "", "epo_leave_group_ack");
      return true;
   }

   iComms.Shout(ship, "", "epo_refuse_group_change");
   return false;
}




////////////////
// Capture Ship
//
// Finds the first ship in the group with marines.
// Docks the ship to the players target.
// Starts the capture task.

task capture_task(hship marines, hship target) {
   int timer;
   bool docked = false;

   while (1) {
      Task.Sleep(Task.Current(), 5.0);

      // Check if we are docked, begin boarding operations.
      if (iSim.IsDockedTo(marines, target)) {
         timer = timer - 5;

         if (false == docked) {
            docked = true;
            iComms.Shout(marines, "", "BeginBoarding");
         }

         // Time is up, we captured the target!
         if (timer < 0) {
            iShip.UndockSelf(marines);

            iComms.Shout(marines, "", "BoardingSuccessful");

            tEpicFleet.FireShip(marines);
            tEpicFleet.CaptureShip(target);
            return;
         }
      } else if (OT_Dock != iAI.CurrentOrderType(marines)) {
         // Check if the player has given this ship new orders.
         // It will no longer have a dock order.
         debug {
            Debug.PrintString("Player changed orders, capture task exiting\n");
         }
         return;
      }
   }
}


bool CaptureShip(int group, hship target) {
   hfaction player_faction = iFaction.Find("Player");
   list fleet;
   int i, total;
   hship ship, group_leader;
   hship player = iShip.FindPlayerShip();
   int valid_types  = T_CommandSection |
                      T_Utility |
                      T_Passenger |
                      T_Fighter |
                      T_Tug |
                      T_Freighter |
                      T_Interceptor;


   fleet = tEpicFleet.ReturnGroup(group);
   group_leader = iShip.Cast(List.Head(fleet));

   if (none == target) {
      iComms.Shout(group_leader, "", "epo_refuse_no_target");
      return false;
   }

   if (Global.Float("gt_distance_wakeup") < Sim.DistanceBetween(target, player)) {
      iComms.Shout(group_leader, "", "epo_refuse_target_far");
      return false;
   }


   // Only a limited number of ship types can be captured. 
   if (!(valid_types & iSim.Type(target))) {
      iComms.Shout(group_leader, "", "RefuseCaptureType");
      return false;
   }

   // Refuse to capture player ships. This is one rare case when
   // the player orders must be wrong. The player already owns 
   // this ship.
   if (player_faction == iSim.Faction(target)) {
      iComms.Shout(group_leader, "", "epo_refuse_player_ship_target");
      return false;
   }

   fleet = List.FromSet(iSim.SimsInRadiusFromSet(Set.FromList(tEpicFleet.ReturnGroup(group)), 
                                                 player, Global.Float("gt_distance_wakeup"), TM_Ship));


   total = List.ItemCount(fleet);

   // There are no ships nearby, so tell player that will not work.
   if (total == 0) {
      iComms.Shout(group_leader, "", "epo_refuse_player_far");
      return false;
   }

   for (i=0;i<total;++i) {
      ship = iShip.Cast(List.GetNth(fleet,i));

      if (tEpicFleet.Marines(ship) > 0) {
         iAI.PurgeOrders(ship);
         iAI.GiveDockOrder(ship, target);

         SetPriorOrder(ship, OT_Dock);

         debug {
            Debug.PrintHandle(ship);
            Debug.PrintString(" Capture Ship\n");
            Debug.PrintHandle(target);
            Debug.PrintString(" Target\n");
         }

         Task.Detach(start capture_task(ship, target));

         // We found a ship that can do the job.
         // Return true.
         iComms.Shout(ship, "", "epo_capture_ack");
         return true;
      }
   }

   // No ships in this group have marines. Return false.
   iComms.Shout(group_leader, "", "epo_refuse_no_marines");
   return false;
}

// One of the more complex commands. It will find all unattached player pods
// near the player. Then it will try to dock those pods.
// It only tries to dock pods to freighters, utility and tug vessels.

// To take illegal pods, or force warships to carry pods,
// the player can issue a dock to target command.

bool CollectPods(int group) {
   hship player = iShip.FindPlayerShip();
   set pods;

   debug {
      //Debug.PrintString("EPO Collectpods\n");
   }

   // Get a list of player pods.
//   pods = Set.FromList(tPodUtil.UndockedPodList(player, Global.Float("gt_distance_wakeup")));

   pods = Set.FromList(tPodUtil.TaggedPodList(player, Global.Float("gt_distance_wakeup")));

   return DockPodSet(group, pods);
}


bool DockPod(int group) {
   set pods;
   hisim target, group_leader;
   list fleet;
   hship player = iShip.FindPlayerShip();
   hfaction player_faction = iFaction.Find("Player");

   target = iShip.CurrentTarget(player);

   fleet = tEpicFleet.ReturnGroup(group);
   group_leader = iShip.Cast(List.Head(fleet));


   // Only dock cargo pods.
   if (T_CargoPod != iSim.Type(target)) {
      iComms.Shout(group_leader, "", "epo_not_cargo_pod");
      return false;
   }

   // Don't dock sold pods.
   if (Object.BoolProperty(target, "md_epic_podsold"))
   {
	   iComms.Shout(group_leader, "", "epo_not_player_pod");
	   return false;
   }

   // Only dock player controlled pods.
   if (player_faction != iSim.Faction(target)) {
      iComms.Shout(group_leader, "", "epo_not_player_pod");
      return false;
   }

   Set.Add(pods, target);

   return DockPodSet(group, pods);
}



bool UndockAllPods(int group) {
   hship player = iShip.FindPlayerShip();
   hship freighter;
   hship pod;
   hdockport dock;

   list children;
   list freight_list;
   set dock_ports;
   int i,j, total, total_pods;
   bool ship_docked = false;
   debug {
      //Debug.PrintString("EPO Undock pods\n");
   }

   // Get a list of freighters and utility ships.
   freight_list = List.FromSet(iSim.SimsInRadiusFromSet( Set.FromList(tEpicFleet.ReturnGroup(group)),
                                                         player,
                                                         Global.Float("gt_distance_wakeup"),
                                                         T_Freighter|T_Utility));

   total = List.ItemCount(freight_list);

   for (i=0;i<total;++i) {
      freighter = iShip.Cast(List.GetNth(freight_list,i));

      if(!Object.PropertyExists(freighter, "md_epic_shipinit"))	// No ditching on the spewer!
      {
         if(!tMegaTrucking.IsMegafreighter(freighter))
         {

            children = List.FromSet(Sim.Children(freighter));
            total_pods = List.ItemCount(children);

            debug {
               //Debug.PrintString(String.FormatInt("Child Sims %d\n",total_pods));
            }
            for (j=0;j<total_pods;++j) {
               pod = iShip.Cast(List.GetNth(children,j));
               if (T_CargoPod == iSim.Type(pod)) {
                  iSim.SetDockingLock(freighter, pod, false);
                  iShip.UndockSelf(pod);
               }
            }	// end for(j...)
         } // end if(!tMegaTrucking...)
         else{
            tMegaTrucking.DitchPods(freighter);
         }

      } else { // end if(!Object...)
         // We had to skip this ship because it is loading/unloading pods
         // so warn the player when this is all done.
         ship_docked = true;
      }
   }	// end for(each wingman in group...)

   // We want to warn the player if they had freighters in the group docked to a pod
   // pod spewer at the time they gave the order.

   if(ship_docked){	// If there is a ship in the group and its on the spewer, complain.
      iHUD.PlayAudioCue(AC_InvalidInput);
      iHUD.Print("UNDOCK THE SHIP FIRST");
      return false;
   } 

   return true;
}



// When the ships free dockports drop to this number,
// revert the ship back to escorting the player.
task pod_dock_task(hship freighter, int dockports)
{
   set dock_ports;
   hship player;
   int timer = 30;

   while (1) {
      Task.Sleep(Task.Current(), 1.0);

      if (Sim.IsDead(freighter)) {
         return;
      }

      // When the ship has docked the number of pods
      // the player ordered, we return the ship to 
      // formate with the player.
      dock_ports = tPodUtil.DockPorts(freighter);
      if (Set.ItemCount(dock_ports) <= dockports) {

         --timer;

         if (timer < 0) {
            player = iShip.FindPlayerShip();
            iAI.PurgeOrders(freighter);
            iAI.GiveEscortOrder(freighter, 
                                player,
                                tFormation.Xpos(freighter),
                                tFormation.Ypos(freighter),
                                tFormation.Zpos(freighter),
                                50km);

            debug Debug.PrintString("tEPlayerOrders.pod_dock_task ship loaded\n");

            // We are done!
            return;
         }
      }
   }
}


// Used by other functions to actually dock the pod to a player group of ships.
bool DockPodSet(int group, set pods) {
   hship player = iShip.FindPlayerShip();
   hship freighter;
   hship pod;
   hisim waypoint;
   hdockport dock;

   list freight_list;
   set dock_ports;
   int i, total, docking_pods;
   bool ship_docked = false;

   debug {
      Debug.PrintString("EPO Collectpods\n");
   }

   // Get a list of freighters and utility ships.
   freight_list = List.FromSet(iSim.SimsInRadiusFromSet( Set.FromList(tEpicFleet.ReturnGroup(group)),
                                                         player,
                                                         Global.Float("gt_distance_wakeup"),
                                                         T_Freighter|T_Utility));

   total = List.ItemCount(freight_list);

   debug {
      //Debug.PrintString(String.FormatInt("EPO Player Pods %d\n",Set.ItemCount(pods)));
      //Debug.PrintString(String.FormatInt("EPO Player Ships %d\n",List.ItemCount(freight_list)));
   }

   for (i=0;i<total;++i) {
      freighter = iShip.Cast(List.GetNth(freight_list,i));

      if (!Object.PropertyExists(freighter, "md_epic_shipinit")) { // No loading pods when on the spewer!

         if (!tMegaTrucking.IsMegafreighter(freighter)) { // Megafreighters use their own method
            dock_ports = tPodUtil.DockPorts(freighter);

            /*
            debug {
                 Debug.PrintHandle(freighter);
                 Debug.PrintString(" freighter\n");
                Debug.PrintString(String.FormatInt("EPO Dockports %d\n",Set.ItemCount(dock_ports)));
                }
            */

            // If this ship can load, and there are pods that need to be loaded,
            // We formate the ship with a stationary waypoint to keep it from
            // moving while the cargo pods attempt to load.
            if ((!(Set.IsEmpty(dock_ports) || Set.IsEmpty(pods)))) {

               waypoint = iSim.Cast(Sim.Create("ini:/sims/nav/waypoint","load point"));
               Sim.PlaceAt(waypoint, freighter);
               Sim.CopyOrientation(waypoint, freighter);
               iAI.PurgeOrders(freighter);
               iAI.GiveFormateOrder( freighter, waypoint, 0.0, 0.0, 0.0 );
               SetPriorOrder(freighter, OT_Formate);

               docking_pods = Set.ItemCount(dock_ports) - Set.ItemCount(pods);
               if (docking_pods < 0) {
                  docking_pods = 0;
               }

               Task.Detach(start pod_dock_task(freighter, docking_pods));
            }

            while (!(Set.IsEmpty(dock_ports) || Set.IsEmpty(pods))) {
               // Match up the pods and dockports one to one,
               // and send the pods to dock with them.
               dock = iDockport.Cast(Set.FirstElement(dock_ports));
               Set.Remove(dock_ports, dock);
               pod = iShip.Cast(Set.FirstElement(pods));
               Set.Remove(pods, pod);
               tPodUtil.AutodockPod(pod, freighter, dock);
            }  // end while
         } else { // end if(!tMegaTrucking...)

            // Here's how we load a megafreighter
            if (!Set.IsEmpty(pods)) {
               waypoint = iSim.Cast(Sim.Create("ini:/sims/nav/waypoint", "load point"));
               Sim.PlaceAt(waypoint, freighter);
               Sim.CopyOrientation(waypoint, freighter);
               iAI.PurgeOrders(freighter);
               iAI.GiveFormateOrder(freighter, waypoint, 0, 0, 0);

               tMegaTrucking.LoadShipFromSpace(freighter, pods);
            } // end if(!Set.IsEmpty)
         }// 
      } // end if(!Object.BoolProperty...)
      else {
         // One of the player ships was docked onto the pod spewer while giving this 
         // command. We skip this ship. Remember for later so we can warn the player.
         ship_docked = true;
      } // end else(if(!Object.BoolProperty...))
   }  // end for


   if (ship_docked) {   // If the one ship in the group is on the spewer, complain until the player cries.
      iHUD.PlayAudioCue(AC_InvalidInput);
      iHUD.Print("UNDOCK THE SHIP FIRST");
      return false;
   }

   return true;
}

// Don't allow attacks on planets, nebula or other non-ship or station type items.
bool is_valid_target(hisim target)
{
   if (iSim.Type(target) & (TM_Ship | T_Asteroid | T_CargoPod | T_Gunstar | T_Station | T_BioBomber)) {
      return true;
   }

   return false;
}

// Don't allow approch orders to stars or planets or missiles or other odd items.
bool is_valid_destination(hisim target)
{
   if (iSim.Type(target) & (TM_Ship | T_Waypoint | T_LagrangePoint | T_Asteroid | T_CargoPod
                            | T_Gunstar | T_Station | T_BioBomber)) {
      return true;
   }

   return false;
}


bool station_known(int station_type) {

   switch (station_type) {
   case ept_PirateBase :
   case ept_PirateCove :
   case ept_PirateOutpost:
   case ept_GangsterHideout:
      return false;
      break;
   default:
      break;
   }

   return true;
} 



bool is_mine(hhabitat station) {
   int station_type;


   if (T_Station != iSim.Type(iSim.Cast(station))) {
      return false;
   }

   station_type = tLProduction.GetType(iSim.Cast(station));

   switch (station_type) {
   case HT_WaterMine:
   case HT_OrganicsMine:
   case HT_InorganicsMine:
   case HT_BiomassMine:
   case HT_CommonMetalsMine:
   case HT_RareMetalsMine:
   case HT_ExoticMetalsMine:
   case HT_RadioactivesMine:
   case HT_FusionableGasesMine:
   case HT_NeutroniumMine:
      return true;
      break;
   default:
      break;
   }

   return false;
}


/*    
THIS MOD IS NOT MADE, DISTRIBUTED, OR SUPPORTED BY INFOGRAMES
OR PARTICLE SYSTEMS LTD. 

ELEMENTS TM & (C) INFOGRAMES AND PARTICLE SYSTEMS LTD.
*/
