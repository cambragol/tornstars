//*******************************************************************************************/
//
// tJumpSim.pog
//
// Implements an lpoint search feature. It allows placing search waypoints where an 
// lpoint might be located. The player can fly to these locations to reveal hidden 
// lpoints.
//
//
// October 2005, Jon Freise
//******************************************************************************************/

package tJumpSim;


uses iShip, Global, Object, Sim, Input, iMapEntity, Math, iAI, Task, Debug, iFaction, iSim, 
   iFactionScript, iComms, INIFile, iUtilities, iPilotSetup,
   iConversation, iFormation, Group, Text, iEmail, State, 
   iTrafficCreation, iRangeCheck,iRemotePilot, iRegion, iMissionTracker, 
   iWingmen, iCargoScript, iShipCreation, iHUD, iScriptedOrders, iStation, 
   iStartSystem, iObjectives, iMultiplay, iCutsceneUtilities,iDirector, 
   iEscort, iLagrangePoint, iMusic, iGame, Stream, iGUI,
   tEpicGuiEnum,
   tEpicGui,
   UniGUI;



provides RunCheck,
         StartPress,
         ShipPress,
         RoutePress,
         StartScreen,
         ExitScreen,
         DisplayWindow;



prototype refresh_ship_list();

prototype refresh_route_list();



prototype hwindow create_button(hwindow parent, int x, int y, string name, string function);


prototype task setup_simulation();

prototype hsim create_waypoint(hsim marker, float distance, float radius, float angle, string name);


prototype task waypoint_watch(hsim waypoint, hsim endpoint);

prototype endpoint_watch(hsim waypoint, hsim endpoint);


prototype hsim create_light(hsim start_mark, float distance, float radius, string template_name);


prototype create_lights(hsim start_mark, hsim end, float min_radius, 
                        float max_radius, string template_name, int total_lights, hgroup cull_group);






RunCheck()
{
   Global.SetBool("g_zz_ug_passme",true);

}




hwindow create_ship_list(hwindow parent, 
                         int x, int y, 
                         int width, int height, 
                         string function)
{
   hwindow list_box;
   hwindow base_win;
   hwindow button;
   int count;
   string ship_name;
   int left;
   int cwidth = width - 4;
   hinifile sim_file = INIFile.Create("ini:/jump_sim");
   
   cwidth = cwidth - Global.Int("GUI_scrollbar_width");

   base_win = GUI.CreateWindow(x, y, width, height, parent);

   // Create the parent listbox
   list_box = GUI.CreateListBox( 0, 0,
                                 cwidth, height,
                                 base_win,
                                 true,
                                 false);

   

   count =0;
   while (INIFile.NumberedExists(sim_file,"Ships","template",count)) {
      ship_name = INIFile.NumberedString(sim_file,"Ships","template",count,"Invalid");

      button = iGUI.CreateAndInitialiseInverseButton( none, 0, 0, 
                                                      cwidth, 
                                                      ship_name,
                                                      function);
      
      Object.AddIntProperty(button,"gtShipIndex",count);

      GUI.AddListBoxEntry(list_box, button);

      ++count;
   }


   INIFile.Destroy(sim_file);


   // Add a scroll bar to the listbox.
   // GUI.CreateVerticalScrollbarDecorator( list_box );

   GUI.CreateVerticalScrollbar( cwidth+4,
                                0,
                                Global.Int("GUI_scrollbar_width"),
                                height,
                                base_win,
                                list_box,
                                Global.Float( "GUI_scrollbar_buttonratio"), 
                                "");

   return base_win;
}



hwindow create_route_list(hwindow parent, 
                         int x, int y, 
                         int width, int height, 
                         string function)
{
   hwindow list_box;
   hwindow base_win;
   hwindow button;
   int count;
   string route_name;
   int left;
   int cwidth = width - 4;
   hinifile sim_file = INIFile.Create("ini:/jump_sim");
   
   cwidth = cwidth - Global.Int("GUI_scrollbar_width");

   base_win = GUI.CreateWindow(x, y, width, height, parent);

   // Create the parent listbox
   list_box = GUI.CreateListBox( 0, 0,
                                 cwidth, height,
                                 base_win,
                                 true,
                                 false);

   

   count =0;
   while (INIFile.NumberedExists(sim_file,"Routes","name",count)) {
      route_name = INIFile.NumberedString(sim_file,"Routes","name",count,"Invalid");

      button = iGUI.CreateAndInitialiseInverseButton( none, 0, 0, 
                                                      cwidth, 
                                                      route_name,
                                                      function);
      
      Object.AddIntProperty(button,"gtRouteIndex",count);

      GUI.AddListBoxEntry(list_box, button);

      ++count;
   }


   INIFile.Destroy(sim_file);


   // Add a scroll bar to the listbox.
   // GUI.CreateVerticalScrollbarDecorator( list_box );

   GUI.CreateVerticalScrollbar( cwidth+4,
                                0,
                                Global.Int("GUI_scrollbar_width"),
                                height,
                                base_win,
                                list_box,
                                Global.Float( "GUI_scrollbar_buttonratio"), 
                                "");

   return base_win;
}




ShipPress()
{
   hwindow button =	GUI.FocusedWindow();

   Global.CreateInt("tJumpSimShip",
                    GA_Write|GA_NoSave,
                    Object.IntProperty(button,"gtShipIndex"));
}



RoutePress()
{
   hwindow button =	GUI.FocusedWindow();

   Global.CreateInt("tJumpSimRoute",
                    GA_Write|GA_NoSave,
                    Object.IntProperty(button,"gtRouteIndex"));
}



StartPress()
{

   Task.Detach(start setup_simulation());

   UniGUI.UniGUIClose();
}




DisplayWindow()
{

   hwindow shady_bar;
   hwindow title;
   hwindow subtitle;
   hwindow exit;
   hwindow help_win;

   int width, height, offset, x, y;

   list inventory_list, empty_list;

   debug Debug.PrintString("tJumpSim.DisplayWindow\n");

   Global.CreateHandle("gt_jumpsim_gui_ship_list_box",GA_Write|GA_NoSave,none);
   Global.CreateHandle("gt_jumpsim_gui_route_list_box",GA_Write|GA_NoSave,none);


   // Set left shady bar width.
   shady_bar = iGUI.CreateWideShadyBar();
   Global.CreateHandle("gt_jumpsim_gui_shady",GA_Write,shady_bar);


   GUI.SetWindowClientArea( shady_bar, 
                            0,
                            0,
                            500,
                            GUI.WindowCanvasHeight( shady_bar));
   


   height = GUI.WindowCanvasHeight( shady_bar);
   height = height - Global.Int("EpicGui_content_drop");
   height = height - Global.Int("EpicGui_content_footer");
   // Take out double the footer space to leave room for the launch button.
   height = height - Global.Int("EpicGui_content_footer");

   offset = height /2;

   width = 500; //GUI.WindowCanvasWidth( shady_bar);
   //width = width/2;
   width = width - Global.Int("EpicGui_content_indent");
   width = width - Global.Int("EpicGui_content_indent");
      

   tEpicGui.CreateTitle(shady_bar, "JUMP SIM");
   tEpicGui.CreateSubtitle(shady_bar, "Capsule Jump Race Sim");

   // Create the exit button
   tEpicGui.CreateExitButton(shady_bar, "EXIT", "tJumpSim.ExitScreen");


   iGUI.CreateAndInitialiseStaticWindow( Global.Int("EpicGui_content_indent"),
                                         Global.Int("EpicGui_content_drop"),
                                         width,
                                         20,
                                         shady_bar,
                                         Global.String("GUI_title_font"),
                                         "Ships");


   iGUI.CreateAndInitialiseStaticWindow( Global.Int("EpicGui_content_indent"),
                                         Global.Int("EpicGui_content_drop")+offset,
                                         width,
                                         20,
                                         shady_bar,
                                         Global.String("GUI_title_font"),
                                         "Routes");
   refresh_ship_list();

   refresh_route_list();


   y = GUI.WindowCanvasHeight( shady_bar );

   // y position uses back button position, add room for fancy border, add a little whitespace
   y= y - Global.Int("EpicGui_content_footer");
   // use double footer spacing, to allow room
   y= y - Global.Int("EpicGui_content_footer");
   y=y+10;
   y = y - Global.Int("GUI_fancybutton_alignmentoffset");
   x = Global.Int("GUI_backbutton_left");

   create_button(shady_bar,x, y, "Start Sim", "tJumpSim.StartPress");

   y= y - Global.Int("EpicGui_content_footer");

   // create_button(shady_bar,x, y, Text.Field( "jumpsim_gui_activate", FT_Text), "tJumpSim.ActivatePress");
                                         

   /*
   // Create help window
   
   help_win = iGUI.CreateAndInitialiseTextWindow(250+Global.Int("EpicGui_content_indent"),
                                      Global.Int("EpicGui_content_drop") ,
                                      275,
                                      height,
                                      shady_bar,
                                      "html:/html/jumpsim_help");

   GUI.CreateVerticalScrollbar( 525+Global.Int("EpicGui_content_indent"),
                                Global.Int("EpicGui_content_drop") ,
                                Global.Int("GUI_scrollbar_width"),
                                height,
                                shady_bar,
                                help_win,
                                Global.Float( "GUI_scrollbar_buttonratio"), 
                                "");
                                */
                                
}


refresh_ship_list()
{
   hwindow list_box = GUI.Cast(Global.Handle("gt_jumpsim_gui_ship_list_box"));
   hwindow base_win = GUI.Cast(Global.Handle("gt_jumpsim_gui_shady"));
   int height, width;

   if (none != list_box) {
      GUI.DeleteWindow(list_box);
   }

   height = GUI.WindowCanvasHeight( base_win);
   height = height - Global.Int("EpicGui_content_drop");
   height = height - Global.Int("EpicGui_content_footer");
   height = height - Global.Int("EpicGui_content_footer");
   // mark out room for the text fields
   height = height - 40;
   height = height/2;

   debug Debug.PrintString(String.FormatInt("HackGui Window height %d\n",height));

   width = 500; //GUI.WindowCanvasWidth( shady_bar);
   //width = width/2;
   width = width - Global.Int("EpicGui_content_indent");
   width = width - Global.Int("EpicGui_content_indent");


   list_box = create_ship_list(base_win, 
                               Global.Int("EpicGui_content_indent"),
                               Global.Int("EpicGui_content_drop")+20,
                               width,
                               height,
                               "tJumpSim.ShipPress"); 



   Global.SetHandle("gt_jumpsim_gui_ship_list_box",list_box);
}


refresh_route_list()
{
   hwindow list_box = GUI.Cast(Global.Handle("gt_jumpsim_gui_route_list_box"));
   hwindow base_win = GUI.Cast(Global.Handle("gt_jumpsim_gui_shady"));
   int height, width, offset;

   if (none != list_box) {
      GUI.DeleteWindow(list_box);
   }

   height = GUI.WindowCanvasHeight( base_win);
   height = height - Global.Int("EpicGui_content_drop");
   height = height - Global.Int("EpicGui_content_footer");
   height = height - Global.Int("EpicGui_content_footer");
   // mark out room for the text fields
   height = height - 40;
   height = height/2;
   offset = height + 40;

   debug Debug.PrintString(String.FormatInt("HackGui Window height %d\n",height));

   width = 500; //GUI.WindowCanvasWidth( shady_bar);
   //width = width/2;
   width = width - Global.Int("EpicGui_content_indent");
   width = width - Global.Int("EpicGui_content_indent");


   list_box = create_route_list(base_win, 
                               Global.Int("EpicGui_content_indent"),
                               Global.Int("EpicGui_content_drop")+ offset,
                               width,
                               height,
                               "tJumpSim.RoutePress"); 



   Global.SetHandle("gt_jumpsim_gui_route_list_box",list_box);
}


StartScreen()
{
   GUI.PopScreensTo("icSpaceFlightScreen");
   GUI.OverlayScreen("icPDAOverlayManager");
   iGUI.OverlayCustomScreen( "tJumpSim.DisplayWindow" );
}




ExitScreen()
{

	UniGUI.UniGUIRemoveScreen();
}



hwindow create_button(hwindow parent, int x, int y, string name, string function)
{
   hwindow button, border;
   int height, width, text_off;

   height = Global.Int("GUI_fancybutton_height")/3;
   width = Global.Int("GUI_fancybutton_width")/2;
   text_off = Global.Int("GUI_fancybutton_textoffset");

   button = GUI.CreateButton(x, y, width, height, parent);

   GUI.SetWindowTitle(button,name);

   GUI.SetWindowFont(button, Global.String("GUI_title_font"));

   //GUI.SetButtonText(button, name);

   GUI.SetWindowTextFormatting( button,
                                false,
                                text_off);

   // Exit button is in white.
   GUI.SetWindowStateColours( button,
                              0.9,0.9,0.9,
                              0.9,0.9,0.9,
                              0.9,0.9,0.9);

   GUI.SetButtonFunctionPog(button, function);

   // Add the border
   
   border = GUI.CreateBorder(button);

   GUI.SetWindowStateColours( border,
                              0.9,0.9,0.9,
                              0.9,0.9,0.9,
                              0.9,0.9,0.9);

   return border;
}

/*
[Routes]

name[0]="Stable 20k 2k Route"
course_distance[0]=20000
points[0]=2000

min_radius[0]=1000
max_radius[0]=2000

degree_shift_min[0]=10
degree_shift_max[0]=20

percent_reverse[0]=0.2

*/

task setup_simulation()
{
   string route_name, ship_name, center_sim, light_sim;

   int route_number, ship_number;
   int min_radius, max_radius;
   int degree_min, degree_max;
   int number_points, point_counter;
   int total_lights;

   float reverse_chance;
   float course_length, point_length, current_distance;
   float current_angle, increment_distance, direction, adjustment;
   float light_radius_max, light_radius_min;

   hinifile sim_file = INIFile.Create("ini:/jump_sim");

   hsim start_marker, end_marker, waypoint, prior_waypoint;
   hsim first_marker, second_marker;
   hsim center_beam;
   
   hship player = iShip.FindPlayerShip();
   hship capsule_ship;

   hgroup sim_group = Group.Create();


   debug Debug.PrintString("tJumpSim.setup_simulation\n");


   route_number = Global.Int("tJumpSimRoute");
   ship_number = Global.Int("tJumpSimShip");


   // Read in the ship setup information.
   ship_name = INIFile.NumberedString(sim_file,"Ships","template",ship_number,"Invalid");

   // Read in the route setup information
   route_name = INIFile.NumberedString(sim_file,"Routes","name",route_number,"Invalid");
   course_length = INIFile.NumberedFloat(sim_file,"Routes","course_distance",route_number,5km);
   number_points = INIFile.NumberedInt(sim_file,"Routes","points",route_number,5);

   min_radius = INIFile.NumberedInt(sim_file,"Routes","min_radius",route_number,5000);
   max_radius = INIFile.NumberedInt(sim_file,"Routes","max_radius",route_number,10000);

   degree_min = INIFile.NumberedInt(sim_file,"Routes","degree_shift_min",route_number,10);
   degree_max = INIFile.NumberedInt(sim_file,"Routes","degree_shift_max",route_number,20);

   reverse_chance = INIFile.NumberedFloat(sim_file,"Routes","percent_reverse",route_number,0.0);


   // Read the Routes graphical setup information.
   // Every route can have a different look.
   center_sim = INIFile.NumberedString(sim_file,"Routes","center_sim", route_number,
                                       "ini:/sims/weapons/antimatter_beam");

   light_sim = INIFile.NumberedString(sim_file,"Routes","light_sim", route_number,
                                      "ini:/sims/ships/utility/cargo_pod");

   // A total number of lights are placed, and random distances along the route. This
   // should give a very scattered and not-human feel to the route.
   total_lights = INIFile.NumberedInt(sim_file,"Routes","total_lights", route_number,20);

   // Lights are placed a random distance from the center between these two amounts
   light_radius_min = INIFile.NumberedFloat(sim_file,"Routes","min_light_radius", route_number,1000.0);
   light_radius_max = INIFile.NumberedFloat(sim_file,"Routes","max_light_radius", route_number,2000.0);


   INIFile.Destroy(sim_file);

   
   
   current_angle = Math.Random(0.0, 360.0);
   direction = 1.0;
   increment_distance = course_length/number_points;

   // Place the first waypoint off which the rest are based.
   start_marker = create_waypoint(player, 
                                  10km, 
                                  0.0,
                                  current_angle,
                                  "Start");

   // Place the first waypoint off which the rest are based.
   end_marker = create_waypoint(start_marker, 
                                  course_length, 
                                  0.0,
                                  current_angle,
                                  "End");

   Group.AddSim(sim_group, start_marker);
   Group.AddSim(sim_group, end_marker);


   // Setup the graphical elements.
   center_beam = Sim.Create(center_sim,"core");
   Sim.SetCullable(center_beam, false);
   iSim.SetSensorVisibility(iSim.Cast(center_beam), true);

   Sim.PlaceRelativeToInside(center_beam, start_marker, 0.0, 0.0, 0.0);
   Sim.PointAt(center_beam, end_marker);

   Object.SetFloatProperty(center_beam, "length", Sim.DistanceBetween(start_marker, end_marker));


   create_lights(start_marker, end_marker, light_radius_min, light_radius_max, 
                 light_sim, total_lights, sim_group);





   prior_waypoint = start_marker;


   for (point_counter=0;point_counter<number_points;++point_counter)
   {
      // Check if we are reversing rotation.
      if (Math.Random(0.0, 1.0) < reverse_chance)
      {
         direction = direction * -1.0;
      }

      // Calculate the new angle
      adjustment = direction * Math.Random(degree_min, degree_max);
      current_angle = current_angle + adjustment;

      current_distance = increment_distance * point_counter;

      // Place the next point
      waypoint = create_waypoint(start_marker, 
                                 current_distance,
                                 Math.Random(min_radius, max_radius),
                                 current_angle,
                                 String.FormatInt("Waypoint %d",point_counter));

      Group.AddSim(sim_group, waypoint);

      Object.AddHandleProperty(prior_waypoint,"next_waypoint", waypoint);

      prior_waypoint = waypoint;

      Task.Detach(start waypoint_watch(waypoint, end_marker));

      if (point_counter == 0)
      {
         first_marker = waypoint;
      }else if (point_counter == 1){
         second_marker = waypoint;
      }
   }

   Object.AddHandleProperty(prior_waypoint,"next_waypoint", end_marker);


   // Put the player into a new ship.
   capsule_ship = iShip.Create(ship_name,"Jump Capsule");

   Group.AddSim(sim_group, capsule_ship);

   // Give the waypoints time to come into existance.
   Task.Sleep(Task.Current(), 0.1);


   // move the player to the new ship.
   iShip.InstallPlayerPilot(capsule_ship);



   // Put the player at the first mark, and give him a shove toward the second mark.
   Sim.PlaceAt(capsule_ship, first_marker);
   Sim.PointAt(capsule_ship, second_marker);
   Sim.SetVelocityLocalToSim(capsule_ship, 0, 0, 100);

   Global.CreateInt("tJumpTime", GA_Write|GA_NoSave, iGame.GameTime());


   // Wait here for the simulation to finish. Then report back how much 
   // damage following wingmen should take.
   endpoint_watch(waypoint, end_marker);



   // Return the player to his own ship, allows a closer look at the course.
   iShip.InstallPlayerPilot(player);

   Task.Sleep(Task.Current(), 10.0);

   Group.Destroy(sim_group, true);

   Task.Sleep(Task.Current(), 1.0);
}


hsim create_waypoint(hsim marker, float distance, float radius, float angle, string name)
{
   hsim waypoint;
   float x, y;


   waypoint = Sim.Create("ini:/sims/nav/waypoint", name);

   Sim.SetCullable(waypoint, false);
   iSim.SetSensorVisibility(iSim.Cast(waypoint), true);

   x = radius * Math.Cos(angle);
   y = radius * Math.Sin(angle);

   Sim.PlaceRelativeToInside(waypoint, marker, x, y, distance);

   return waypoint;
}


task waypoint_watch(hsim waypoint, hsim endpoint)
{
   hship player;
   float end_distance, player_distance;


   end_distance = Sim.DistanceBetween(waypoint, endpoint);

   while (1)
   {
      Task.Sleep(Task.Current(), 0.5);

      if (Sim.IsDead(waypoint))
      {
         // Our sim is dead, we get out.
         return;
      }

      player = iShip.FindPlayerShip();

      // The player is close to us, we move his hud to the next target
      // and bail out.
      if (Sim.DistanceBetween(player, waypoint) < 1km)
      {
         iHUD.SetTarget(Sim.Cast(Object.HandleProperty(waypoint,"next_waypoint")));
         iHUD.PlayAudioCue(AC_ValidInput);
         return;
      }

      // If the player has moved closer to the end that we are, 
      // then we have been bypassed. Normally, we do damage
      // to the player at this point, but not now.
      // we give the player a little extra distance, because
      // to counter any time lag.
      player_distance = Sim.DistanceBetween(player, endpoint);
      player_distance = player_distance + 1km;
      if (player_distance < end_distance)
      {
         iHUD.SetTarget(Sim.Cast(Object.HandleProperty(waypoint,"next_waypoint")));
         iHUD.PlayAudioCue(AC_InvalidInput);
         return;
      }
   }
}


// This function is much like the waypoint watch, but it returns
// to end the simulation.
endpoint_watch(hsim waypoint, hsim endpoint)
{
   hship player;
   float end_distance, player_distance;
   int time;

   end_distance = Sim.DistanceBetween(waypoint, endpoint);

   while (1)
   {
      Task.Sleep(Task.Current(), 0.5);

      if (Sim.IsDead(waypoint))
      {
         // Our sim is dead, we get out.
         return;
      }

      player = iShip.FindPlayerShip();

      // The player is close to us, we move his hud to the next target
      // and bail out.
      if (Sim.DistanceBetween(player, waypoint) < 1km)
      {
         iHUD.SetTarget(Sim.Cast(Object.HandleProperty(waypoint,"next_waypoint")));
         iHUD.PlayAudioCue(AC_ValidInput);

         time = iGame.GameTime() - Global.Int("tJumpTime");
         iComms.Shout(none,"",String.FormatInt("CourseTime %d Seconds", time));
         return;
      }

      // If the player has moved closer to the end that we are, 
      // then we have been bypassed. Normally, we do damage
      // to the player at this point, but not now.
      // we give the player a little extra distance, because
      // to counter any time lag.
      player_distance = Sim.DistanceBetween(player, endpoint);
      player_distance = player_distance + 1km;
      if (player_distance < end_distance)
      {
         iHUD.SetTarget(Sim.Cast(Object.HandleProperty(waypoint,"next_waypoint")));
         iHUD.PlayAudioCue(AC_InvalidInput);

         time = iGame.GameTime() - Global.Int("tJumpTime");
         iComms.Shout(none,"",String.FormatInt("CourseTime %d Seconds", time));

         // We would shut down the simulation here.
         return;
      }

   }  

}


// Creates the glowing lights streaming down the center of the jump path
// using the provided sim template.

create_lights(hsim start_mark, hsim end, float min_radius, float max_radius, 
              string template_name, int total_lights, hgroup cull_group)
{
   int i;
   float distance, radius, length;
   hsim light;

   length = Sim.DistanceBetween(start_mark, end);

   for (i=0;i<total_lights;++i)
   {
      radius = Math.Random(min_radius, max_radius);

      distance = Math.Random(1, length);

      light = create_light(start_mark, distance, radius, template_name);

      Group.AddSim(cull_group, light);

   }

}


// Creates one light at random position around the jump path center.

hsim create_light(hsim start_mark, float distance, float radius, string template_name)
{
   hsim waypoint;
   float x, y, angle;

   waypoint = Sim.Create(template_name, "light");

   Sim.SetCullable(waypoint, false);
   //iSim.SetSensorVisibility(iSim.Cast(waypoint), true);

   angle = Math.Random(0.0, 360.0);
   x = radius * Math.Cos(angle);
   y = radius * Math.Sin(angle);

   Sim.PlaceRelativeToInside(waypoint, start_mark, x, y, distance);

   return waypoint;
}

/* 
THIS MOD IS NOT MADE, DISTRIBUTED, OR SUPPORTED BY INFOGRAMES
OR PARTICLE SYSTEMS LTD. 

ELEMENTS TM & (C) INFOGRAMES AND PARTICLE SYSTEMS LTD.
*/
