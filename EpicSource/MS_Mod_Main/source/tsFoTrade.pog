/*******************************************************************************************/
//
// tsFoTrade.pog
// 
// Torn Stars Fleet Operation Trade
// 
// This function implements the decision making intellegence of an
// Trade type of Fleet Operation.
// 
// Template: Jon - March 2006
//
// Updates: JW - May 2008
//
//******************************************************************************************/

package tsFoTrade;


//[of]:Impports
uses  Sim,
iSim,
Debug,
Global,
iGame,
iFaction,
INIFile,
Input,
List,
Object,
String,
Task,
State,
Text,
Math,
iShip,
iHabitat,
iMapEntity,
iHUD,
iComms,
CargoTypes,
iCargo,
   tsEconUtil,
   tsStationEnum,
   tsStation,
   tsFaction,
   tsTime,
   tsFleetOp,
   tsLCenter,
   tsLProduction,
   tsLFleet,
   tsStationFilter,
   tsShipName,
   tsShipCreationEnum,
   tsShipCreation,
   tsFleetOpCombat,
   tsFleetOpPhysical,
   tsDebug;
//[cf]


//[of]:Exports
provides New,
         Save,
         Restore,
         Update,
         PlayerNear;
//[cf]



prototype hhabitat find_production_station(hisim operation, hmapentity center, string system_name);

prototype bool is_production(hmapentity center);

prototype hhabitat find_non_dislike_station(hisim operation, hmapentity center, string system_name);

//*******************************************************************************************/         
//
//*******************************************************************************************/



// Create the new FO and perform any property setups
New(hisim operation)
{
   string ship_name, ship_template;
   hfaction faction;
   string op_type_str;
   string env_file_name;
   string ship_class;
   hinifile ini_file;

   debug Debug.PrintString("tsFoTrade.New\n");

   faction = iSim.Faction(operation);

   // We pick a general name for ourselves. 
   // using a large number means we get a random name.
   ship_name = tsShipName.ShipName("general", 10000);

   // get the operation type as a string
   op_type_str = tsEconUtil.StationIntToString( tsFleetOp.GetOperationType(operation) );
   
   // hook into station_status_env.ini and get the appropriate ini
   // file which will hold the ship faction template
   ini_file = INIFile.Create("ini:/station_status_env");
   if(none == ini_file) {
      Debug.PrintString("tsFoTanker.New: ERROR: station_status_env.ini not opened. Defaults taken.");
   }
   env_file_name = INIFile.NumberedString(ini_file, op_type_str, "ESS_Normal", 0, "ini:/env_fo_trade");
   INIFile.Destroy(ini_file);

   ini_file = INIFile.Create(env_file_name);
   if(none == ini_file) {
      Debug.PrintString(  String.FormatStrStr("tsFoTanker.New: ERROR: %s not opened. Defaults taken.\n",env_file_name,"") );
   }
   ship_class = INIFile.NumberedString(ini_file, "Items", "faction_ship_class", 0, "EST_FreightAll");
   INIFile.Destroy(ini_file);

   // Get the ship template based on faction
   ship_template = tsShipCreation.GetShip(faction, tsShipCreation.String2ShipType(ship_class));

   tsFleetOp.SetName(operation, ship_name);
   tsFleetOp.SetShipTemplate(operation, ship_template);

   // Trade ops want to avoid pirates, including player pirates so they run silent.
   tsFleetOp.SetKnown(operation, false);

   // This is a Trade op, so we set enough fleets for the 
   // freighter and 'x' tug escorts. Fleets use threat value for points.
   tsLFleet.SetFleets(operation, 200);
   tsLFleet.SetMaxFleets(operation, 200);
}



Save(hisim operation)
{
   // Nothing to save for this operation type.
}



Restore(hisim operation)
{
   // Nothing to restore for this operation type.
}


// The FO's behaviour function
Update(hisim operation)
{
   hmapentity center = tsLCenter.GetCenter(operation);
   hhabitat target_station, supporter_station;
   bool hostiles, wounded, home, move_home, move_production;
   list local_operations;
   hisim visitor;
   hfaction faction, visitor_faction;
   int fleets, i, total;
   int update_delay = 1;

   debug tsDebug.PrintString("tsFoTrade_debug","tsFoTrade.Update\n");

   
   faction = iSim.Faction(operation);


   // If hostiles nearby flee, no matter what.
   // If we are wounded, stay at home.
   // If we are wounded, and not at home, move home, turn hidden.
   // If we are at home, and not wounded, move to a station to sell goods at.

   // Here we look up what other operations are nearby.
   // Any combat between this and other operations happens here.

   local_operations = tsFleetOp.StationOperations(center);
   List.Remove(local_operations, operation);
   total = List.ItemCount(local_operations);

   hostiles = false;

   for (i=0;i<total;++i) {
      visitor = iSim.Cast(List.GetNth(local_operations,i));
      visitor_faction = iSim.Faction(visitor);

      if (iFaction.Feeling(visitor_faction, faction) < -0.2) {
         // Trade always evades.
         tsFleetOpCombat.Defense(center, operation, visitor);

         hostiles = true;
      }
   }

   fleets = tsLFleet.Fleets(operation);

   if (fleets == 0) {
      // Ouch, we died.
      debug tsDebug.PrintString("tsFoTrade_debug","tsFoTrade lost fleets and died\n");

      tsFleetOp.DestroyOp(operation);
      return;
   }

   // Are we damaged? Trade operations are wimpy.
   // They assume any damage is wounded.
   if (fleets < tsLFleet.MaxFleets(operation)) {
      wounded = true;
   }else {
      wounded = false;
   }

   supporter_station = tsFleetOp.Supporter(operation);

   // Are we home?
   if (center == iMapEntity.Cast(supporter_station)) {
      home = true;
   }else {
      home = false;
   }

   move_home = false;
   move_production = false;


   if (hostiles && !wounded) {
      // if we are just scared, find another station.
      move_production = true;
   }else if (hostiles) {
      // if we got hurt, run home.
      move_home = true;
   }else if (wounded && !home) {
      move_home = true;
   }else if (!wounded && !is_production(center)){
      move_production = true;
   } else {
    // need to go somewhere for next sale.
    move_production = true;
   }


   // If we are at home, repair some fleets.
   if (home) {
      tsLFleet.ChangeFleets(operation, 10 * update_delay);

      debug tsDebug.PrintString("tsFoTrade_debug",String.FormatInt("tsFoTrade repairing at home %d fleets\n", 
                                               tsLFleet.Fleets(operation)));
   }

   if (move_home) {

      tsLCenter.SetCenter(operation, supporter_station);
      tsFleetOpCombat.SetDistressFlags(supporter_station);

      debug {
         tsDebug.PrintString("tsFoTrade_debug","tsFoTrade moving home\n");
         tsDebug.PrintHandle("tsFoTrade_debug",supporter_station);
         tsDebug.PrintString("tsFoTrade_debug"," supporter station\n");
      }

   }else if (move_production) {

      target_station = find_production_station(operation, center, iSim.WorldName(center));

      if (none != target_station) {
         // To move an operation, we just move the center.
         tsLCenter.SetCenter(operation, target_station);
      tsFleetOpCombat.SetDistressFlags(target_station);
      }else {
         // We must be running, so pick any nearby non-hostile station.
         target_station = find_non_dislike_station(operation, center, iSim.WorldName(center));

         if (none != target_station) {
            // To move an operation, we just move the center.
            tsLCenter.SetCenter(operation, target_station);
            tsFleetOpCombat.SetDistressFlags(target_station);
         }else {
            tsLCenter.SetCenter(operation, supporter_station);
            tsFleetOpCombat.SetDistressFlags(supporter_station);
         }
      }

      debug {
         tsDebug.PrintString("tsFoTrade_debug","tsFoTrade moving to production\n");
         tsDebug.PrintHandle("tsFoTrade_debug",target_station);
         tsDebug.PrintString("tsFoTrade_debug"," new station\n");
      }
   }

   // Next update, tomorrow.
   tsFleetOp.SetWakeTimer(operation, tsTime.GetDay() + update_delay);
}


// Called when the player is near the operation
PlayerNear(hisim operation)
{
   debug Debug.PrintString("tsFoTrade.PlayerNear: Player near operation, instantiate physical sims.\n");
   tsFleetOpPhysical.MakeOpPhysical(operation);
}

// Return true if this location is an operating production station.
bool is_production(hmapentity center)
{
   if (T_Station == iSim.Type(center)) {
      if (ESS_Normal == tsStation.Status(iHabitat.Cast(center))) {
         if ( (ESC_Mine|ESC_Process|ESC_Manufacture) & tsStation.Category(iHabitat.Cast(center))){
            return true;
         }
      }
   }
   return false;
}

hhabitat find_production_station(hisim operation, hmapentity center, string system_name)
{
   set habitats;

   // Search system stations and find a production station where we can live.
   habitats = tsStationFilter.OnStatusAndCategory(iMapEntity.SystemHabitatsInSystem(system_name),
                                                 ESS_Normal,
                                                 (ESC_Mine|ESC_Process|ESC_Manufacture));

   Set.Remove(habitats, center);
   // We can hang out at neutral or better stations. We avoid people trying to
   // kill us.
   habitats = tsStationFilter.OnGreaterFeeling(habitats,
                                              iSim.Faction(operation),
                                              tsFaction.Type2LowerLevel(FT_Neutral));

   return iHabitat.Random(habitats);
}

hhabitat find_non_dislike_station(hisim operation, hmapentity center, string system_name)
{
   set habitats;

   // We can hang out at neutral or better stations.
   // We avoid people trying to kill us.
   habitats = tsStationFilter.OnGreaterFeeling(iMapEntity.SystemHabitatsInSystem(system_name),
                                              iSim.Faction(operation),
                                              tsFaction.Type2LowerLevel(FT_Neutral));
   Set.Remove(habitats, center);

   return iHabitat.Random(habitats);
}

/*  
THIS MOD IS NOT MADE, DISTRIBUTED, OR SUPPORTED BY INFOGRAMES
OR PARTICLE SYSTEMS LTD. 

ELEMENTS TM & (C) INFOGRAMES AND PARTICLE SYSTEMS LTD.
*/