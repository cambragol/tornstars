#!/usr/bin/env python
#
# $Id$
#
# parses a .pog file and lists the dependancies
#
# this was hacked up from the parse_headers bit of the decompiler.
#
# someone should learn antlar and write a pog grammer.
#

import string, sys, re, os

ure = re.compile('^uses')

class PogParser:
	def __init__(self, verbose = 0):
		self.verbose = verbose
	
	def parse(self, file):
		fh = open(file, "r")
		self.fh = fh
		name = os.path.basename(file)
#		dir = os.path.dirname(file)
		# we assume the include_ps headers never change
		# XXX don't bother actually. We might want to,
		# but one thing at a time.
#		if dir.endswith('include_ps'):
#			return None
		

		if name.endswith('.pog'):
			self.name = name[:-4]
		elif name.endswith('.h'):
			self.name = name[:-2]

		# or uses
		# maybe parse the 'package' declerations as well, then we can check
		# that thats the same as the filename (will cause problems if there
		# different).
		state = 'looking'
		usesaccum = ''
		
		# sucks that python dosn't ship with a lex/yacc type of thing.
		for line in fh:
			line = line.strip()
			if line.startswith('//'):
				continue
			elif line == '':
				continue
			elif re.match('^\s+$', line):
				continue
			elif re.match('^\s*//', line):
				continue
			elif line.startswith('#'):
				continue
#			elif line.startswith('FLUX_DECLARE_EXTENSION('):
#				continue
			elif line.startswith('/*'):
				continue
			elif line.startswith('*'): # also */
				continue
			elif line.find('//') != -1:
				line = line[:line.find('//')]
				line = line.strip()

			if state == 'looking':
				if ure.search(line):
#					print 'found a uses', line
					state = 'uses'
					usesaccum += line
					if line.endswith(';'):
						fh.close()
						return self.done_uses(usesaccum)
					continue

				if self.verbose:
					print '%',line,'%'
				continue

			elif state == 'uses':
				usesaccum += line
				if line.find(';') != -1:
					fh.close()
					return self.done_uses(usesaccum)
		
		return []

	def done_uses(self, usesaccum):
#		print 'end uses'
		uses = []
		assert usesaccum.find('uses') == 0
		assert usesaccum[-1:] == ';'
		usesaccum = usesaccum[4:-1]
		usesaccum = usesaccum.replace(' ', '')
		if usesaccum.startswith('\t'):
			usesaccum = usesaccum[1:]
		uses =  usesaccum.split(',')
		uses.sort()
		#
		# HACK HACK HACK
		#
		# Fix filename case inconsistancys
		#
		tolower = {'Stream' : 'stream', 'iGame' : 'igame', 'iDockPort' : 'iDockport', 'iAi' : 'iAI'}
		for i,e in enumerate(uses):
			if e in tolower:
				# lowercase in include_ps...
				# or other case mismatch
				uses[i] = tolower[e]
		uses = [x + '.h' for x in uses]

		return uses
		

def sortmaker(d):
	return lambda x,y: cmp(d[x], d[y])

if __name__ == "__main__":
	paths = None
	
	if len(sys.argv) > 1:
		paths = sys.argv[1:]
	else:
		base = os.getenv('EPIC_BASE')
		if base != None:
			paths = []
			dirs = ((base, 'EpicSource', 'pog', 'include_pkg'),
							(base, 'EpicSource', 'pog', 'include'),
							(base, 'EpicSource', 'pog', 'include_ps'),
							(base, 'EpicSource', 'MS_Mod_Main', 'source'))
			for d in dirs:
				paths.append(os.path.sep.join(d))
					
			
	if paths == None:
		print "usage %s : (<directory>+)" % (sys.argv[0])
		sys.exit(-1)
		
	deps = {}
	headers = {}
	
	for p in paths:
		for ent in os.listdir(p):
			if ent.endswith('.pog') or ent.endswith('.h'):
				ppr = PogParser()
				uses = ppr.parse(os.path.join(p, ent))
#				if uses != []:
#					print ent, 'uses', str(uses)
				assert ent not in deps, 'more then one %s' % (ent)
				deps[ent] = uses
			if ent.endswith('.h'):
				assert ent not in headers
				headers[ent] = 1

	ks = deps.keys()
	def sorter(x, y):
		# same file extention?
		if x[-1:] == y[-1:]:
			return cmp(x, y)

		(cx,cy) = (0, 0)

		if x.endswith('h'):
			cx = -1
		elif x.endswith('g'):
			cx = 1

		if y.endswith('h'):
			cy = -1
		elif y.endswith('g'):
			cy = 1
		return cmp(cx, cy)
			
	ks.sort(sorter)
	for k in ks:
		if k.endswith('pog'):
			for i in deps[k]:
				assert i in headers, '%s not in headers!' % (i)

	print '# Generated by $File$ - $Id$'

	for k in ks:
		if k.endswith('pog'):
			#
			# HACK HACK HACK
			#
			# The source files are mixed case, but pc.exe spits our lowercase files.
			# On a system with a case sensitive filesystem this means that gmake never
			# sees that the targets have been made with the %.pkg : %.pog rule.
			#
			# I think that the gmake shipped with cygwin is case insensative, so it
			# dosn't have that problem. My laptop does tho.
			#
			# hack around this by spitting out a rule for each and every .pog file.
			#
			# note that a package will still have to be in $(PACKAGES) in the make
			# file to be built!
			#
			print k[:-4].lower() + '.pkg : ' + k 
			print "\t$(POG_COMPILER) -q -i $(INCLUDE_PATH) -i $(PS_INCLUDE_PATH) -i $(INCLUDE_PKG) -hp $(CODE_PATH)/include_tmp -pp $(PACKAGE_PATH) $<"
			print "\tcp $(PACKAGE_PATH)/$@ $(MOD_PATH)/packages"
			print

	print '# header files are commented out, dependancies are here for'
	print '# interest only'

	for k in ks:
		#print k#, deps[k]
		# skip files with no includes
		if deps[k] == []:
			continue

		if k.endswith('h'):
			# we have dependancy info for header files, but
			# do we really want to do anything with it in the makefile ?
			# dump it here as a comment anyway
			print '# ' + k + ': ' + ' '.join(deps[k])
			print
		else:
			# and the .pkg deps.
			print k[:-4].lower() + '.pkg : ' + k + ' ' + ' '.join(deps[k])
			print
